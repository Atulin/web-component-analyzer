(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["wca"],{

/***/ "../../web-component-analyzer/lib/esm/api.js":
/*!**********************************************************************!*\
  !*** /Users/rune/Developer/js/web-component-analyzer/lib/esm/api.js ***!
  \**********************************************************************/
/*! exports provided: ALL_COMPONENT_FEATURES, VERSION, analyzeSourceFile, getExtendsHeritageClauses, getExtendsHeritageClausesInChain, getMixinHeritageClauses, getMixinHeritageClausesInChain, getSuperclassHeritageClause, transformAnalyzerResult, visitAllHeritageClauses, analyzeHTMLElement, analyzeText */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"analyzeHTMLElement\", function() { return analyzeHTMLElement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"analyzeText\", function() { return analyzeText; });\n/* harmony import */ var _chunk_2799b223_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-2799b223.js */ \"../../web-component-analyzer/lib/esm/chunk-2799b223.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ALL_COMPONENT_FEATURES\", function() { return _chunk_2799b223_js__WEBPACK_IMPORTED_MODULE_0__[\"A\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"VERSION\", function() { return _chunk_2799b223_js__WEBPACK_IMPORTED_MODULE_0__[\"V\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"analyzeSourceFile\", function() { return _chunk_2799b223_js__WEBPACK_IMPORTED_MODULE_0__[\"b\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getExtendsHeritageClauses\", function() { return _chunk_2799b223_js__WEBPACK_IMPORTED_MODULE_0__[\"f\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getExtendsHeritageClausesInChain\", function() { return _chunk_2799b223_js__WEBPACK_IMPORTED_MODULE_0__[\"i\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getMixinHeritageClauses\", function() { return _chunk_2799b223_js__WEBPACK_IMPORTED_MODULE_0__[\"e\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getMixinHeritageClausesInChain\", function() { return _chunk_2799b223_js__WEBPACK_IMPORTED_MODULE_0__[\"h\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getSuperclassHeritageClause\", function() { return _chunk_2799b223_js__WEBPACK_IMPORTED_MODULE_0__[\"g\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"transformAnalyzerResult\", function() { return _chunk_2799b223_js__WEBPACK_IMPORTED_MODULE_0__[\"t\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"visitAllHeritageClauses\", function() { return _chunk_2799b223_js__WEBPACK_IMPORTED_MODULE_0__[\"v\"]; });\n\n/* harmony import */ var typescript__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! typescript */ \"../../web-component-analyzer/node_modules/typescript/lib/typescript.js\");\n/* harmony import */ var typescript__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(typescript__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var ts_simple_type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ts-simple-type */ \"../../web-component-analyzer/node_modules/ts-simple-type/lib/index.cjs.js\");\n/* harmony import */ var ts_simple_type__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ts_simple_type__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\n\n\n\n/**\n * Analyzes components in code\n * @param {IVirtualSourceFile[]|VirtualSourceFile} inputFiles\n * @param config\n */\nfunction analyzeText(inputFiles, config) {\n    if (config === void 0) { config = {}; }\n    var ts = config.ts || typescript__WEBPACK_IMPORTED_MODULE_1__;\n    // \"sys\" can be undefined when running in the browser\n    var system = ts.sys;\n    // Convert arguments into virtual source files\n    var files = (Array.isArray(inputFiles) ? inputFiles : [inputFiles])\n        .map(function (file) {\n        return typeof file === \"string\"\n            ? {\n                text: file,\n                fileName: \"auto-generated-\" + Math.floor(Math.random() * 100000) + \".ts\",\n                entry: true\n            }\n            : file;\n    })\n        .map(function (file) { return (Object(_chunk_2799b223_js__WEBPACK_IMPORTED_MODULE_0__[\"_\"])(Object(_chunk_2799b223_js__WEBPACK_IMPORTED_MODULE_0__[\"_\"])({}, file), { fileName: file.fileName })); });\n    var readFile = function (fileName) {\n        var matchedFile = files.find(function (currentFile) { return currentFile.fileName === fileName; });\n        return matchedFile == null ? undefined : matchedFile.text;\n    };\n    var fileExists = function (fileName) {\n        return files.some(function (currentFile) { return currentFile.fileName === fileName; });\n    };\n    var compilerOptions = {\n        module: ts.ModuleKind.ESNext,\n        target: ts.ScriptTarget.ESNext,\n        allowJs: true,\n        sourceMap: false,\n        strictNullChecks: true\n    };\n    var program = ts.createProgram({\n        rootNames: files.map(function (file) { return file.fileName; }),\n        options: compilerOptions,\n        host: {\n            writeFile: function () { },\n            readFile: readFile,\n            fileExists: fileExists,\n            getSourceFile: function (fileName, languageVersion) {\n                var sourceText = this.readFile(fileName);\n                if (sourceText == null)\n                    return undefined;\n                return ts.createSourceFile(fileName, sourceText, languageVersion, true, fileName.endsWith(\".js\") ? typescript__WEBPACK_IMPORTED_MODULE_1__[\"ScriptKind\"].JS : typescript__WEBPACK_IMPORTED_MODULE_1__[\"ScriptKind\"].TS);\n            },\n            getCurrentDirectory: function () {\n                return \".\";\n            },\n            getDirectories: function (directoryName) {\n                var _a, _b;\n                return _b = (_a = system) === null || _a === void 0 ? void 0 : _a.getDirectories(directoryName), (_b !== null && _b !== void 0 ? _b : []);\n            },\n            getDefaultLibFileName: function (options) {\n                return ts.getDefaultLibFileName(options);\n            },\n            getCanonicalFileName: function (fileName) {\n                return this.useCaseSensitiveFileNames() ? fileName : fileName.toLowerCase();\n            },\n            getNewLine: function () {\n                var _a, _b;\n                return _b = (_a = system) === null || _a === void 0 ? void 0 : _a.newLine, (_b !== null && _b !== void 0 ? _b : \"\\n\");\n            },\n            useCaseSensitiveFileNames: function () {\n                var _a, _b;\n                return _b = (_a = system) === null || _a === void 0 ? void 0 : _a.useCaseSensitiveFileNames, (_b !== null && _b !== void 0 ? _b : false);\n            }\n        }\n    });\n    var checker = program.getTypeChecker();\n    // Analyze source files\n    var sourceFilesToAnalyze = Object(_chunk_2799b223_js__WEBPACK_IMPORTED_MODULE_0__[\"a\"])(files.filter(function (file) { return file.analyze !== false; }).map(function (file) { return program.getSourceFile(file.fileName); }));\n    var results = sourceFilesToAnalyze.map(function (sf) { return Object(_chunk_2799b223_js__WEBPACK_IMPORTED_MODULE_0__[\"b\"])(sf, Object(_chunk_2799b223_js__WEBPACK_IMPORTED_MODULE_0__[\"_\"])({ program: program }, config)); });\n    return { checker: checker, program: program, results: results, analyzedSourceFiles: sourceFilesToAnalyze };\n}\n\n/**\n * This function only analyzes the HTMLElement declaration found in \"lib.dom.d.ts\" source file provided by Typescript.\n * @param program\n * @param ts\n */\nfunction analyzeHTMLElement(program, ts) {\n    if (ts === void 0) { ts = typescript__WEBPACK_IMPORTED_MODULE_1__; }\n    var endsWithLibDom = \"lib.dom.d.ts\";\n    var domLibSourceFile = program.getSourceFiles().find(function (sf) { return sf.fileName.endsWith(endsWithLibDom); });\n    if (domLibSourceFile == null) {\n        return undefined;\n        //throw new Error(`Couldn't find '${endsWith}'. Have you included the 'dom' lib in your tsconfig?`);\n    }\n    return visit(domLibSourceFile, Object(_chunk_2799b223_js__WEBPACK_IMPORTED_MODULE_0__[\"_\"])(Object(_chunk_2799b223_js__WEBPACK_IMPORTED_MODULE_0__[\"_\"])({}, Object(_chunk_2799b223_js__WEBPACK_IMPORTED_MODULE_0__[\"m\"])({\n        program: program,\n        ts: ts,\n        flavors: [new _chunk_2799b223_js__WEBPACK_IMPORTED_MODULE_0__[\"C\"]()],\n        config: {\n            analyzeDefaultLib: true,\n            features: _chunk_2799b223_js__WEBPACK_IMPORTED_MODULE_0__[\"A\"]\n        }\n    })), { cache: {\n            featureCollection: _chunk_2799b223_js__WEBPACK_IMPORTED_MODULE_0__[\"D\"],\n            componentDeclaration: _chunk_2799b223_js__WEBPACK_IMPORTED_MODULE_0__[\"c\"],\n            general: new Map()\n        } }));\n}\nfunction visit(node, context) {\n    if (context.ts.isInterfaceDeclaration(node) && node.name != null && node.name.text === \"HTMLElement\") {\n        return Object(_chunk_2799b223_js__WEBPACK_IMPORTED_MODULE_0__[\"d\"])([node], context);\n    }\n    return node.forEachChild(function (child) {\n        return visit(child, context);\n    });\n}\n\n\n\n\n//# sourceURL=webpack:////Users/rune/Developer/js/web-component-analyzer/lib/esm/api.js?");

/***/ }),

/***/ "../../web-component-analyzer/lib/esm/chunk-2799b223.js":
/*!*********************************************************************************!*\
  !*** /Users/rune/Developer/js/web-component-analyzer/lib/esm/chunk-2799b223.js ***!
  \*********************************************************************************/
/*! exports provided: A, C, D, V, _, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, s, t, v */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"A\", function() { return ALL_COMPONENT_FEATURES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"C\", function() { return CustomElementFlavor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"D\", function() { return DEFAULT_FEATURE_COLLECTION_CACHE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"V\", function() { return VERSION; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_\", function() { return __assign; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return arrayDefined; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return analyzeSourceFile; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return DEFAULT_COMPONENT_DECLARATION_CACHE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return analyzeComponentDeclaration; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return getMixinHeritageClauses; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return getExtendsHeritageClauses; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"g\", function() { return getSuperclassHeritageClause; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return getMixinHeritageClausesInChain; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"i\", function() { return getExtendsHeritageClausesInChain; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"j\", function() { return __awaiter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"k\", function() { return __generator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"l\", function() { return __values; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"m\", function() { return makeContextFromConfig; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"n\", function() { return arrayFlat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"o\", function() { return __read; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"s\", function() { return stripTypescriptValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"t\", function() { return transformAnalyzerResult; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"v\", function() { return visitAllHeritageClauses; });\n/* harmony import */ var typescript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! typescript */ \"../../web-component-analyzer/node_modules/typescript/lib/typescript.js\");\n/* harmony import */ var typescript__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(typescript__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var ts_simple_type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ts-simple-type */ \"../../web-component-analyzer/node_modules/ts-simple-type/lib/index.cjs.js\");\n/* harmony import */ var ts_simple_type__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ts_simple_type__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nfunction __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\n\n/**\n * Takes a node and tries to resolve a constant value from it.\n * Returns undefined if no constant value can be resolved.\n * @param node\n * @param context\n */\nfunction resolveNodeValue(node, context) {\n    var e_1, _a, e_2, _b;\n    var _c, _d;\n    if (node == null)\n        return undefined;\n    var ts = context.ts, checker = context.checker;\n    var depth = (context.depth || 0) + 1;\n    // Always break when depth is larger than 10.\n    // This ensures we cannot run into infinite recursion.\n    if (depth > 10)\n        return undefined;\n    if (ts.isStringLiteralLike(node)) {\n        return { value: node.text, node: node };\n    }\n    else if (ts.isNumericLiteral(node)) {\n        return { value: Number(node.text), node: node };\n    }\n    else if (ts.isPrefixUnaryExpression(node)) {\n        var value = (_c = resolveNodeValue(node.operand, __assign(__assign({}, context), { depth: depth }))) === null || _c === void 0 ? void 0 : _c.value;\n        return { value: applyPrefixUnaryOperatorToValue(value, node.operator, ts), node: node };\n    }\n    else if (ts.isObjectLiteralExpression(node)) {\n        var object = {};\n        try {\n            for (var _e = __values(node.properties), _f = _e.next(); !_f.done; _f = _e.next()) {\n                var prop = _f.value;\n                if (ts.isPropertyAssignment(prop)) {\n                    // Resolve the \"key\"\n                    var name_1 = ((_d = resolveNodeValue(prop.name, __assign(__assign({}, context), { depth: depth }))) === null || _d === void 0 ? void 0 : _d.value) || prop.name.getText();\n                    // Resolve the \"value\n                    var resolvedValue = resolveNodeValue(prop.initializer, __assign(__assign({}, context), { depth: depth }));\n                    if (resolvedValue != null && typeof name_1 === \"string\") {\n                        object[name_1] = resolvedValue.value;\n                    }\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_f && !_f.done && (_a = _e.return)) _a.call(_e);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return {\n            value: object,\n            node: node\n        };\n    }\n    else if (node.kind === ts.SyntaxKind.TrueKeyword) {\n        return { value: true, node: node };\n    }\n    else if (node.kind === ts.SyntaxKind.FalseKeyword) {\n        return { value: false, node: node };\n    }\n    else if (node.kind === ts.SyntaxKind.NullKeyword) {\n        return { value: null, node: node };\n    }\n    else if (node.kind === ts.SyntaxKind.UndefinedKeyword) {\n        return { value: undefined, node: node };\n    }\n    // Resolve initializers for variable declarations\n    if (ts.isVariableDeclaration(node)) {\n        return resolveNodeValue(node.initializer, __assign(__assign({}, context), { depth: depth }));\n    }\n    // Resolve value of a property access expression. For example: MyEnum.RED\n    else if (ts.isPropertyAccessExpression(node)) {\n        return resolveNodeValue(node.name, __assign(__assign({}, context), { depth: depth }));\n    }\n    // Resolve [expression] parts of {[expression]: \"value\"}\n    else if (ts.isComputedPropertyName(node)) {\n        return resolveNodeValue(node.expression, __assign(__assign({}, context), { depth: depth }));\n    }\n    // Resolve initializer value of enum members.\n    else if (ts.isEnumMember(node)) {\n        if (node.initializer != null) {\n            return resolveNodeValue(node.initializer, __assign(__assign({}, context), { depth: depth }));\n        }\n        else {\n            return { value: node.parent.name.text + \".\" + node.name.getText(), node: node };\n        }\n    }\n    // Resolve values of variables.\n    else if (ts.isIdentifier(node) && checker != null) {\n        var declarations = resolveDeclarations(node, { checker: checker, ts: ts });\n        if (declarations.length > 0) {\n            var resolved = resolveNodeValue(declarations[0], __assign(__assign({}, context), { depth: depth }));\n            if (context.strict || resolved != null) {\n                return resolved;\n            }\n        }\n        return { value: node.getText(), node: node };\n    }\n    // Fallthrough\n    //  - \"my-value\" as string\n    //  - <any>\"my-value\"\n    //  - (\"my-value\")\n    else if (ts.isAsExpression(node) || ts.isTypeAssertion(node) || ts.isParenthesizedExpression(node)) {\n        return resolveNodeValue(node.expression, __assign(__assign({}, context), { depth: depth }));\n    }\n    // static get is() {\n    //    return \"my-element\";\n    // }\n    else if ((ts.isGetAccessor(node) || ts.isMethodDeclaration(node) || ts.isFunctionDeclaration(node)) && node.body != null) {\n        try {\n            for (var _g = __values(node.body.statements), _h = _g.next(); !_h.done; _h = _g.next()) {\n                var stm = _h.value;\n                if (ts.isReturnStatement(stm)) {\n                    return resolveNodeValue(stm.expression, __assign(__assign({}, context), { depth: depth }));\n                }\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (_h && !_h.done && (_b = _g.return)) _b.call(_g);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n    }\n    // [1, 2]\n    else if (ts.isArrayLiteralExpression(node)) {\n        return {\n            node: node,\n            value: node.elements.map(function (el) { var _a; return (_a = resolveNodeValue(el, __assign(__assign({}, context), { depth: depth }))) === null || _a === void 0 ? void 0 : _a.value; })\n        };\n    }\n    return undefined;\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction applyPrefixUnaryOperatorToValue(value, operator, ts) {\n    if (typeof value === \"object\" && value != null) {\n        return value;\n    }\n    switch (operator) {\n        case ts.SyntaxKind.MinusToken:\n            return -value;\n        case ts.SyntaxKind.ExclamationToken:\n            return !value;\n        case ts.SyntaxKind.PlusToken:\n            return +value;\n    }\n    return value;\n}\n\n/**\n * Converts from snake case to camel case\n * @param str\n */\n/**\n * Converts from camel case to snake case\n * @param str\n */\nfunction camelToDashCase(str) {\n    return str.replace(/[A-Z]/g, function (m) { return \"-\" + m.toLowerCase(); });\n}\n/**\n * Returns if a name is private (starts with \"_\" or \"#\");\n * @param name\t * @param name\n */\nfunction isNamePrivate(name) {\n    return name.startsWith(\"_\") || name.startsWith(\"#\");\n}\n\n/**\n * Resolves all relevant declarations of a specific node.\n * @param node\n * @param context\n */\nfunction resolveDeclarations(node, context) {\n    if (node == null)\n        return [];\n    var symbol = getSymbol(node, context);\n    if (symbol == null)\n        return [];\n    return resolveSymbolDeclarations(symbol);\n}\n/**\n * Returns the symbol of a node.\n * This function follows aliased symbols.\n * @param node\n * @param context\n */\nfunction getSymbol(node, context) {\n    if (node == null)\n        return undefined;\n    var checker = context.checker, ts = context.ts;\n    // Get the symbol\n    var symbol = checker.getSymbolAtLocation(node);\n    if (symbol == null) {\n        var identifier = getNodeIdentifier(node, context);\n        symbol = identifier != null ? checker.getSymbolAtLocation(identifier) : undefined;\n    }\n    // Resolve aliased symbols\n    if (symbol != null && isAliasSymbol(symbol, ts)) {\n        symbol = checker.getAliasedSymbol(symbol);\n        if (symbol == null)\n            return undefined;\n    }\n    return symbol;\n}\n/**\n * Resolves the declarations of a symbol. A valueDeclaration is always the first entry in the array\n * @param symbol\n */\nfunction resolveSymbolDeclarations(symbol) {\n    // Filters all declarations\n    var valueDeclaration = symbol.valueDeclaration;\n    var declarations = symbol.getDeclarations() || [];\n    if (valueDeclaration == null) {\n        return declarations;\n    }\n    else {\n        // Make sure that \"valueDeclaration\" is always the first entry\n        return __spread([valueDeclaration], declarations.filter(function (decl) { return decl !== valueDeclaration; }));\n    }\n}\n/**\n * Resolve a declaration by trying to find the real value by following assignments.\n * @param node\n * @param context\n */\nfunction resolveDeclarationsDeep(node, context) {\n    var e_1, _a;\n    var declarations = [];\n    var allDeclarations = resolveDeclarations(node, context);\n    try {\n        for (var allDeclarations_1 = __values(allDeclarations), allDeclarations_1_1 = allDeclarations_1.next(); !allDeclarations_1_1.done; allDeclarations_1_1 = allDeclarations_1.next()) {\n            var declaration = allDeclarations_1_1.value;\n            if (context.ts.isVariableDeclaration(declaration) && declaration.initializer != null && context.ts.isIdentifier(declaration.initializer)) {\n                declarations.push.apply(declarations, __spread(resolveDeclarationsDeep(declaration.initializer, context)));\n            }\n            else if (context.ts.isTypeAliasDeclaration(declaration) && declaration.type != null && context.ts.isIdentifier(declaration.type)) {\n                declarations.push.apply(declarations, __spread(resolveDeclarationsDeep(declaration.type, context)));\n            }\n            else {\n                declarations.push(declaration);\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (allDeclarations_1_1 && !allDeclarations_1_1.done && (_a = allDeclarations_1.return)) _a.call(allDeclarations_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return declarations;\n}\n/**\n * Returns if the symbol has \"alias\" flag\n * @param symbol\n * @param ts\n */\nfunction isAliasSymbol(symbol, ts) {\n    return hasFlag(symbol.flags, ts.SymbolFlags.Alias);\n}\n/**\n * Returns a set of modifiers on a node\n * @param node\n * @param ts\n */\nfunction getModifiersFromNode(node, ts) {\n    var modifiers = new Set();\n    if (hasModifier(node, ts.SyntaxKind.ReadonlyKeyword)) {\n        modifiers.add(\"readonly\");\n    }\n    if (hasModifier(node, ts.SyntaxKind.StaticKeyword)) {\n        modifiers.add(\"static\");\n    }\n    if (ts.isGetAccessor(node)) {\n        modifiers.add(\"readonly\");\n    }\n    return modifiers.size > 0 ? modifiers : undefined;\n}\n/**\n * Returns if a number has a flag\n * @param num\n * @param flag\n */\nfunction hasFlag(num, flag) {\n    return (num & flag) !== 0;\n}\n/**\n * Returns if a node has a specific modifier.\n * @param node\n * @param modifierKind\n */\nfunction hasModifier(node, modifierKind) {\n    if (node.modifiers == null)\n        return false;\n    return (node.modifiers || []).find(function (modifier) { return modifier.kind === modifierKind; }) != null;\n}\n/**\n * Returns the visibility of a node\n */\nfunction getMemberVisibilityFromNode(node, ts) {\n    if (hasModifier(node, ts.SyntaxKind.PrivateKeyword) || (\"name\" in node && ts.isIdentifier(node.name) && isNamePrivate(node.name.text))) {\n        return \"private\";\n    }\n    else if (hasModifier(node, ts.SyntaxKind.ProtectedKeyword)) {\n        return \"protected\";\n    }\n    else if (getNodeSourceFileLang(node) === \"ts\") {\n        // Only return \"public\" in typescript land\n        return \"public\";\n    }\n    return undefined;\n}\n/**\n * Returns all keys and corresponding interface/class declarations for keys in an interface.\n * @param interfaceDeclaration\n * @param context\n */\nfunction getInterfaceKeys(interfaceDeclaration, context) {\n    var e_2, _a;\n    var extensions = [];\n    var ts = context.ts;\n    try {\n        for (var _b = __values(interfaceDeclaration.members), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var member = _c.value;\n            // { \"my-button\": MyButton; }\n            if (ts.isPropertySignature(member) && member.type != null) {\n                var resolvedKey = resolveNodeValue(member.name, context);\n                if (resolvedKey == null) {\n                    continue;\n                }\n                var identifier = void 0;\n                var declaration = void 0;\n                if (ts.isTypeReferenceNode(member.type)) {\n                    // { ____: MyButton; } or { ____: namespace.MyButton; }\n                    identifier = member.type.typeName;\n                }\n                else if (ts.isTypeLiteralNode(member.type)) {\n                    identifier = undefined;\n                    declaration = member.type;\n                }\n                else {\n                    continue;\n                }\n                if (declaration != null || identifier != null) {\n                    extensions.push({ key: String(resolvedKey.value), keyNode: resolvedKey.node, declaration: declaration, identifier: identifier });\n                }\n            }\n        }\n    }\n    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n    finally {\n        try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        }\n        finally { if (e_2) throw e_2.error; }\n    }\n    return extensions;\n}\n/**\n * Find a node recursively walking up the tree using parent nodes.\n * @param node\n * @param test\n */\nfunction findParent(node, test) {\n    if (node == null)\n        return;\n    return test(node) ? node : findParent(node.parent, test);\n}\n/**\n * Find a node recursively walking down the children of the tree. Depth first search.\n * @param node\n * @param test\n */\nfunction findChild(node, test) {\n    if (!node)\n        return;\n    if (test(node))\n        return node;\n    return node.forEachChild(function (child) { return findChild(child, test); });\n}\n/**\n * Find multiple children by walking down the children of the tree. Depth first search.\n * @param node\n * @param test\n * @param emit\n */\nfunction findChildren(node, test, emit) {\n    if (!node)\n        return;\n    if (test(node)) {\n        emit(node);\n    }\n    node.forEachChild(function (child) { return findChildren(child, test, emit); });\n}\n/**\n * Returns the language of the node's source file\n * @param node\n */\nfunction getNodeSourceFileLang(node) {\n    return node.getSourceFile().fileName.endsWith(\"ts\") ? \"ts\" : \"js\";\n}\n/**\n * Returns the leading comment for a given node\n * @param node\n * @param ts\n */\nfunction getLeadingCommentForNode(node, ts) {\n    var sourceFileText = node.getSourceFile().text;\n    var leadingComments = ts.getLeadingCommentRanges(sourceFileText, node.pos);\n    if (leadingComments != null && leadingComments.length > 0) {\n        return sourceFileText.substring(leadingComments[0].pos, leadingComments[0].end);\n    }\n    return undefined;\n}\n/**\n * Returns if the node is in a module declaration context and has a specific name.\n * @param node\n * @param context\n * @param name\n */\nfunction isExtensionInterface(node, context, name) {\n    return context.ts.isInterfaceDeclaration(node) /*&& context.ts.isModuleBlock(node.parent)*/ && node.name.text === name;\n}\n/**\n * Returns the declaration name of a given node if possible.\n * @param node\n * @param context\n */\nfunction getNodeName(node, context) {\n    var _a;\n    return (_a = getNodeIdentifier(node, context)) === null || _a === void 0 ? void 0 : _a.getText();\n}\n/**\n * Returns the declaration name of a given node if possible.\n * @param node\n * @param context\n */\nfunction getNodeIdentifier(node, context) {\n    if (context.ts.isClassLike(node) || context.ts.isInterfaceDeclaration(node)) {\n        return node.name;\n    }\n    else if (context.ts.isIdentifier(node)) {\n        return node;\n    }\n    else if (context.ts.isVariableDeclaration(node) && node.name != null && context.ts.isIdentifier(node.name)) {\n        return node.name;\n    }\n    return undefined;\n}\n\n/**\n * Visits custom element definitions.\n * @param node\n * @param ts\n * @param checker\n */\nfunction discoverDefinitions(node, _a) {\n    var ts = _a.ts, checker = _a.checker;\n    // customElements.define(\"my-element\", MyElement)\n    if (ts.isCallExpression(node)) {\n        if (ts.isPropertyAccessExpression(node.expression) && node.expression.name.escapedText === \"define\") {\n            var leftExpression = node.expression.expression;\n            // Take \"window.customElements\" into account and return the \"customElements\" part\n            if (ts.isPropertyAccessExpression(leftExpression) &&\n                ts.isIdentifier(leftExpression.expression) &&\n                leftExpression.expression.escapedText === \"window\") {\n                leftExpression = leftExpression.name;\n            }\n            // Check if the \"left expression\" is called \"customElements\"\n            if (ts.isIdentifier(leftExpression) &&\n                leftExpression.escapedText === \"customElements\" &&\n                node.expression.name != null &&\n                ts.isIdentifier(node.expression.name)) {\n                // Find the arguments of: define(\"my-element\", MyElement)\n                var _b = __read(node.arguments, 2), unresolvedTagNameNode = _b[0], identifierNode = _b[1];\n                // Resolve the tag name node\n                // (\"my-element\", MyElement)\n                var resolvedTagNameNode = resolveNodeValue(unresolvedTagNameNode, { ts: ts, checker: checker, strict: true });\n                if (resolvedTagNameNode != null && identifierNode != null && typeof resolvedTagNameNode.value === \"string\") {\n                    var tagName = resolvedTagNameNode.value;\n                    var tagNameNode = resolvedTagNameNode.node;\n                    // (___, MyElement)\n                    if (ts.isIdentifier(identifierNode)) {\n                        return [\n                            {\n                                tagName: tagName,\n                                identifierNode: identifierNode,\n                                tagNameNode: tagNameNode\n                            }\n                        ];\n                    }\n                    // (___, class { ... })\n                    else if (ts.isClassLike(identifierNode) || ts.isInterfaceDeclaration(identifierNode)) {\n                        return [\n                            {\n                                tagName: tagName,\n                                tagNameNode: tagNameNode,\n                                declarationNode: identifierNode\n                            }\n                        ];\n                    }\n                }\n            }\n        }\n        return undefined;\n    }\n    // interface HTMLElementTagNameMap { \"my-button\": MyButton; }\n    if (ts.isInterfaceDeclaration(node) && [\"HTMLElementTagNameMap\", \"ElementTagNameMap\"].includes(node.name.text)) {\n        var extensions = getInterfaceKeys(node, { ts: ts, checker: checker });\n        return extensions.map(function (_a) {\n            var key = _a.key, keyNode = _a.keyNode, identifier = _a.identifier, declaration = _a.declaration;\n            return ({\n                tagName: key,\n                tagNameNode: keyNode,\n                identifierNode: identifier,\n                declarationNode: declaration\n            });\n        });\n    }\n    return undefined;\n}\n\n/**\n * Flattens an array.\n * Use this function to keep support for node 10\n * @param items\n */\nfunction arrayFlat(items) {\n    var e_1, _a;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if (\"flat\" in items) {\n        return items.flat();\n    }\n    var flattenArray = [];\n    try {\n        for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {\n            var item = items_1_1.value;\n            flattenArray.push.apply(flattenArray, __spread(item));\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return flattenArray;\n}\n/**\n * Filters an array returning only defined items\n * @param array\n */\nfunction arrayDefined(array) {\n    return array.filter(function (item) { return item != null; });\n}\n\nvar NOTHING = Symbol();\n/**\n * This function wraps a callback returning a value and cahced the value.\n * @param callback\n */\nfunction lazy(callback) {\n    var value = NOTHING;\n    return function () {\n        if (value === NOTHING) {\n            value = callback();\n        }\n        return value;\n    };\n}\n\n/**\n * Returns typescript jsdoc node for a given node\n * @param node\n * @param ts\n */\nfunction getJSDocNode(node, ts) {\n    var _a, _b, _c;\n    var parent = (_b = (_a = ts.getJSDocTags(node)) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.parent;\n    if (parent != null && ts.isJSDoc(parent)) {\n        return parent;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return (_c = node.jsDoc) === null || _c === void 0 ? void 0 : _c.find(function (n) { return ts.isJSDoc(n); });\n}\nfunction getJsDoc(node, tagNamesOrTs, ts) {\n    // Overloaded case\n    var tagNames = null;\n    if (ts == null) {\n        ts = tagNamesOrTs;\n    }\n    else {\n        tagNames = tagNamesOrTs;\n    }\n    var jsDocNode = getJSDocNode(node, ts);\n    // If we couldn't find jsdoc, find and parse the jsdoc string ourselves\n    if (jsDocNode == null) {\n        var leadingComment = getLeadingCommentForNode(node, ts);\n        if (leadingComment != null) {\n            return parseJsDocString(leadingComment);\n        }\n        return undefined;\n    }\n    // Parse all jsdoc tags\n    // Typescript removes some information after parsing jsdoc tags, so unfortunately we will have to parse.\n    return {\n        description: jsDocNode.comment == null ? undefined : unescapeJSDoc(String(jsDocNode.comment)),\n        node: jsDocNode,\n        tags: jsDocNode.tags == null\n            ? []\n            : arrayDefined(jsDocNode.tags.map(function (node) {\n                var _a, _b, _c, _d;\n                var tag = String(node.tagName.escapedText);\n                if (tagNames != null && tagNames.length > 0 && !tagNames.includes(tag.toLowerCase())) {\n                    return undefined;\n                }\n                // If Typescript generated a \"type expression\" or \"name\", comment will not include those.\n                // We can't just use what typescript parsed because it doesn't include things like optional jsdoc: name notation [...]\n                // Therefore we need to manually get the text and remove newlines/*\n                var typeExpressionPart = \"typeExpression\" in node ? (_a = node.typeExpression) === null || _a === void 0 ? void 0 : _a.getText() : undefined;\n                var namePart = \"name\" in node ? (_b = node.name) === null || _b === void 0 ? void 0 : _b.getText() : undefined;\n                var fullComment = ((_c = typeExpressionPart) === null || _c === void 0 ? void 0 : _c.startsWith(\"@\")) ? // To make matters worse, if Typescript can't parse a certain jsdoc, it will include the rest of the jsdocs tag from there in \"typeExpressionPart\"\n                    // Therefore we check if there are multiple jsdoc tags in the string to only take the first one\n                    // This will discard the following jsdocs, but at least we don't crash :-)\n                    typeExpressionPart.split(/\\n\\s*\\*\\s?@/)[0] || \"\"\n                    : \"@\" + tag + (typeExpressionPart != null ? \" \" + typeExpressionPart + \" \" : \"\") + (namePart != null ? \" \" + namePart + \" \" : \"\") + \" \" + (node.comment ||\n                        \"\");\n                return {\n                    node: node,\n                    tag: tag,\n                    comment: (_d = node.comment) === null || _d === void 0 ? void 0 : _d.replace(/^\\s*-\\s*/, \"\").trim(),\n                    parsed: lazy(function () { return parseJsDocTagString(fullComment); })\n                };\n            }))\n    };\n}\n/**\n * Converts a given string to a SimpleType\n * Defaults to ANY\n * See http://usejsdoc.org/tags-type.html\n * @param str\n */\nfunction parseSimpleJsDocTypeExpression(str) {\n    // Fail safe if \"str\" is somehow undefined\n    if (str == null) {\n        return { kind: ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].ANY };\n    }\n    // Parse normal types\n    switch (str.toLowerCase()) {\n        case \"undefined\":\n            return { kind: ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].UNDEFINED };\n        case \"null\":\n            return { kind: ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].NULL };\n        case \"string\":\n            return { kind: ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].STRING };\n        case \"number\":\n            return { kind: ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].NUMBER };\n        case \"boolean\":\n            return { kind: ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].BOOLEAN };\n        case \"array\":\n            return { kind: ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].ARRAY, type: { kind: ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].ANY } };\n        case \"object\":\n            return { kind: ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].OBJECT, members: [] };\n        case \"any\":\n        case \"*\":\n            return { kind: ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].ANY };\n    }\n    // Match\n    //  {  string  }\n    if (str.startsWith(\" \") || str.endsWith(\" \")) {\n        return parseSimpleJsDocTypeExpression(str.trim());\n    }\n    // Match:\n    //   {string|number}\n    if (str.includes(\"|\")) {\n        return {\n            kind: ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].UNION,\n            types: str.split(\"|\").map(function (str) {\n                var childType = parseSimpleJsDocTypeExpression(str);\n                // Convert ANY types to string literals so that {on|off} is \"on\"|\"off\" and not ANY|ANY\n                if (childType.kind === ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].ANY) {\n                    return {\n                        kind: ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].STRING_LITERAL,\n                        value: str\n                    };\n                }\n                return childType;\n            })\n        };\n    }\n    // Match:\n    //  {?number}       (nullable)\n    //  {!number}       (not nullable)\n    //  {...number}     (array of)\n    var prefixMatch = str.match(/^(\\?|!|(\\.\\.\\.))(.+)$/);\n    if (prefixMatch != null) {\n        var modifier = prefixMatch[1];\n        var type = parseSimpleJsDocTypeExpression(prefixMatch[3]);\n        switch (modifier) {\n            case \"?\":\n                return {\n                    kind: ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].UNION,\n                    types: [\n                        {\n                            kind: ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].NULL\n                        },\n                        type\n                    ]\n                };\n            case \"!\":\n                return type;\n            case \"...\":\n                return {\n                    kind: ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].ARRAY,\n                    type: type\n                };\n        }\n    }\n    // Match:\n    //  {(......)}\n    var parenMatch = str.match(/^\\((.+)\\)$/);\n    if (parenMatch != null) {\n        return parseSimpleJsDocTypeExpression(parenMatch[1]);\n    }\n    // Match\n    //   {\"red\"}\n    var stringLiteralMatch = str.match(/^[\"'](.+)[\"']$/);\n    if (stringLiteralMatch != null) {\n        return {\n            kind: ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].STRING_LITERAL,\n            value: stringLiteralMatch[1]\n        };\n    }\n    // Match\n    //   {[number]}\n    var arrayMatch = str.match(/^\\[(.+)]$/);\n    if (arrayMatch != null) {\n        return {\n            kind: ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].ARRAY,\n            type: parseSimpleJsDocTypeExpression(arrayMatch[1])\n        };\n    }\n    return { kind: ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].ANY };\n}\n/**\n * Finds a @type jsdoc tag in the jsdoc and returns the corresponding simple type\n * @param jsDoc\n */\nfunction getJsDocType(jsDoc) {\n    var _a;\n    if (jsDoc.tags != null) {\n        var typeJsDocTag = jsDoc.tags.find(function (t) { return t.tag === \"type\"; });\n        if (typeJsDocTag != null) {\n            // We get the text of the node because typescript strips the type jsdoc tag under certain circumstances\n            var parsedJsDoc = parseJsDocTagString(((_a = typeJsDocTag.node) === null || _a === void 0 ? void 0 : _a.getText()) || \"\");\n            if (parsedJsDoc.type != null) {\n                return parseSimpleJsDocTypeExpression(parsedJsDoc.type);\n            }\n        }\n    }\n}\nvar JSDOC_TAGS_WITH_REQUIRED_NAME = [\"param\", \"fires\", \"@element\", \"@customElement\"];\n/**\n * Takes a string that represents a value in jsdoc and transforms it to a javascript value\n * @param value\n */\nfunction parseJsDocValue(value) {\n    if (value == null) {\n        return value;\n    }\n    // Parse quoted strings\n    var quotedMatch = value.match(/^[\"'`](.*)[\"'`]$/);\n    if (quotedMatch != null) {\n        return quotedMatch[1];\n    }\n    // Parse keywords\n    switch (value) {\n        case \"false\":\n            return false;\n        case \"true\":\n            return true;\n        case \"undefined\":\n            return undefined;\n        case \"null\":\n            return null;\n    }\n    // Parse number\n    if (!isNaN(Number(value))) {\n        return Number(value);\n    }\n    return value;\n}\n/**\n * Parses \"@tag {type} name description\"\n * @param str\n */\nfunction parseJsDocTagString(str) {\n    var jsDocTag = {\n        tag: \"\"\n    };\n    if (str[0] !== \"@\") {\n        return jsDocTag;\n    }\n    var moveStr = function (byLength) {\n        str = str.substring(typeof byLength === \"number\" ? byLength : byLength.length);\n    };\n    var unqouteStr = function (quotedStr) {\n        return quotedStr.replace(/^['\"](.+)[\"']$/, function (_, match) { return match; });\n    };\n    // Match tag\n    // Example: \"  @mytag\"\n    var tagResult = str.match(/^(\\s*@(\\S+))/);\n    if (tagResult == null) {\n        return jsDocTag;\n    }\n    else {\n        // Move string to the end of the match\n        // Example: \"  @mytag|\"\n        moveStr(tagResult[1]);\n        jsDocTag.tag = tagResult[2];\n    }\n    // Match type\n    // Example: \"   {MyType}\"\n    var typeResult = str.match(/^(\\s*{([\\s\\S]*)})/);\n    if (typeResult != null) {\n        // Move string to the end of the match\n        // Example: \"  {MyType}|\"\n        moveStr(typeResult[1]);\n        jsDocTag.type = typeResult[2];\n    }\n    // Match optional name\n    // Example: \"  [myname=mydefault]\"\n    var defaultNameResult = str.match(/^(\\s*\\[([\\s\\S]+)\\])/);\n    if (defaultNameResult != null) {\n        // Move string to the end of the match\n        // Example: \"  [myname=mydefault]|\"\n        moveStr(defaultNameResult[1]);\n        // Using [...] means that this doc is optional\n        jsDocTag.optional = true;\n        // Split the inner content between [...] into parts\n        // Example:  \"myname=mydefault\" => \"myname\", \"mydefault\"\n        var parts = defaultNameResult[2].split(\"=\");\n        if (parts.length === 2) {\n            // Both name and default were given\n            jsDocTag.name = unqouteStr(parts[0]);\n            jsDocTag.default = parseJsDocValue(parts[1]);\n        }\n        else if (parts.length !== 0) {\n            // No default was given\n            jsDocTag.name = unqouteStr(parts[0]);\n        }\n    }\n    else {\n        // else, match required name\n        // Example: \"   myname\"\n        // A name is needed some jsdoc tags making it possible to include omit \"-\"\n        // Therefore we don't look for \"-\" or line end if the name is required - in that case we only need to eat the first word to find the name.\n        var regex = JSDOC_TAGS_WITH_REQUIRED_NAME.includes(jsDocTag.tag) ? /^(\\s*(\\S+))/ : /^(\\s*(\\S+))((\\s*-[\\s\\S]+)|\\s*)($|[\\r\\n])/;\n        var nameResult = str.match(regex);\n        if (nameResult != null) {\n            // Move string to end of match\n            // Example: \"   myname|\"\n            moveStr(nameResult[1]);\n            jsDocTag.name = unqouteStr(nameResult[2].trim());\n        }\n    }\n    // Match comment\n    if (str.length > 0) {\n        // The rest of the string is parsed as comment. Remove \"-\" if needed.\n        jsDocTag.description = str.replace(/^\\s*-\\s*/, \"\").trim() || undefined;\n    }\n    // Expand the name based on namespace and classname\n    if (jsDocTag.name != null) {\n        /**\n         * The name could look like this, so we need to parse and the remove the class name and namespace from the name\n         *   InputSwitch#[CustomEvent]input-switch-check-changed\n         *   InputSwitch#input-switch-check-changed\n         */\n        var match = jsDocTag.name.match(/(.*)#(\\[.*\\])?(.*)/);\n        if (match != null) {\n            jsDocTag.className = match[1];\n            jsDocTag.namespace = match[2];\n            jsDocTag.name = match[3];\n        }\n    }\n    return jsDocTag;\n}\n/**\n * Parses an entire jsdoc string\n * @param doc\n */\nfunction parseJsDocString(doc) {\n    var e_1, _a;\n    // Prepare lines\n    var lines = doc.split(\"\\n\").map(function (line) { return line.trim(); });\n    var description = \"\";\n    var readDescription = true;\n    var currentTag = \"\";\n    var tags = [];\n    /**\n     * Parsing will add to \"currentTag\" and commit it when necessary\n     */\n    var commitCurrentTag = function () {\n        if (currentTag.length > 0) {\n            var tagToCommit_1 = currentTag;\n            var tagMatch = tagToCommit_1.match(/^@(\\S+)\\s*/);\n            if (tagMatch != null) {\n                tags.push({\n                    parsed: lazy(function () { return parseJsDocTagString(tagToCommit_1); }),\n                    node: undefined,\n                    tag: tagMatch[1],\n                    comment: tagToCommit_1.substr(tagMatch[0].length)\n                });\n            }\n            currentTag = \"\";\n        }\n    };\n    try {\n        // Parse all lines one by one\n        for (var lines_1 = __values(lines), lines_1_1 = lines_1.next(); !lines_1_1.done; lines_1_1 = lines_1.next()) {\n            var line = lines_1_1.value;\n            // Don't parse the last line (\"*/\")\n            if (line.match(/\\*\\//)) {\n                continue;\n            }\n            // Match a line like: \"* @mytag description\"\n            var tagCommentMatch = line.match(/(^\\s*\\*\\s*)@\\s*/);\n            if (tagCommentMatch != null) {\n                // Commit current tag (if any has been read). Now \"currentTag\" will reset.\n                commitCurrentTag();\n                // Add everything on the line from \"@\"\n                currentTag += line.substr(tagCommentMatch[1].length);\n                // We hit a jsdoc tag, so don't read description anymore\n                readDescription = false;\n            }\n            else if (!readDescription) {\n                // If we are not reading the description, we are currently reading a multiline tag\n                var commentMatch = line.match(/^\\s*\\*\\s*/);\n                if (commentMatch != null) {\n                    currentTag += \"\\n\" + line.substr(commentMatch[0].length);\n                }\n            }\n            else {\n                // Read everything after \"*\" into the description if we are currently reading the description\n                // If we are on the first line, add everything after \"/*\"\n                var startLineMatch = line.match(/^\\s*\\/\\*\\*/);\n                if (startLineMatch != null) {\n                    description += line.substr(startLineMatch[0].length);\n                }\n                // Add everything after \"*\" into the current description\n                var commentMatch = line.match(/^\\s*\\*\\s*/);\n                if (commentMatch != null) {\n                    if (description.length > 0) {\n                        description += \"\\n\";\n                    }\n                    description += line.substr(commentMatch[0].length);\n                }\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (lines_1_1 && !lines_1_1.done && (_a = lines_1.return)) _a.call(lines_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    // Commit a tag if we were currently parsing one\n    commitCurrentTag();\n    if (description.length === 0 && tags.length === 0) {\n        return undefined;\n    }\n    return {\n        description: unescapeJSDoc(description),\n        tags: tags\n    };\n}\n/**\n * Certain characters as \"@\" can be escaped in order to prevent Typescript from\n * parsing it as a jsdoc tag. This function unescapes these characters.\n * @param str\n */\nfunction unescapeJSDoc(str) {\n    return str.replace(/\\\\@/, \"@\");\n}\n\n/**\n * Discovers events dispatched\n * @param node\n * @param context\n */\nfunction discoverEvents(node, context) {\n    var ts = context.ts, checker = context.checker;\n    // new CustomEvent(\"my-event\");\n    if (ts.isNewExpression(node)) {\n        var expression = node.expression, args = node.arguments, typeArguments_1 = node.typeArguments;\n        if (expression.getText() === \"CustomEvent\" && args && args.length >= 1) {\n            var arg = args[0];\n            if (ts.isStringLiteralLike(arg)) {\n                var eventName = arg.text;\n                // Either grab jsdoc from the new expression or from a possible call expression that its wrapped in\n                var jsDoc = getJsDoc(expression, ts) ||\n                    (ts.isCallLikeExpression(node.parent) && getJsDoc(node.parent.parent, ts)) ||\n                    (ts.isExpressionStatement(node.parent) && getJsDoc(node.parent, ts)) ||\n                    undefined;\n                return [\n                    {\n                        jsDoc: jsDoc,\n                        name: eventName,\n                        node: node,\n                        type: lazy(function () {\n                            var _a;\n                            return ((((_a = typeArguments_1) === null || _a === void 0 ? void 0 : _a[0]) != null && checker.getTypeFromTypeNode(typeArguments_1[0])) ||\n                                {\n                                    kind: ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].ANY\n                                });\n                        })\n                    }\n                ];\n            }\n        }\n    }\n    return undefined;\n}\n\n/**\n * Discovers global feature defined on \"HTMLElementEventMap\" or \"HTMLElement\"\n */\nvar discoverGlobalFeatures = {\n    event: function (node, context) {\n        var e_1, _a;\n        var _b, _c, _d, _e;\n        var ts = context.ts;\n        if (isExtensionInterface(node, context, \"HTMLElementEventMap\")) {\n            var events = [];\n            try {\n                for (var _f = __values(node.members), _g = _f.next(); !_g.done; _g = _f.next()) {\n                    var member = _g.value;\n                    if (ts.isPropertySignature(member)) {\n                        var name_1 = (_b = resolveNodeValue(member.name, context)) === null || _b === void 0 ? void 0 : _b.value;\n                        if (name_1 != null && typeof name_1 === \"string\") {\n                            events.push({\n                                node: member.initializer || member,\n                                jsDoc: getJsDoc(member, ts),\n                                name: name_1,\n                                type: lazy(function () { return ({ kind: ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].ANY }); })\n                            });\n                        }\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (_g && !_g.done && (_a = _f.return)) _a.call(_f);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            (_e = (_c = context) === null || _c === void 0 ? void 0 : (_d = _c).emitContinue) === null || _e === void 0 ? void 0 : _e.call(_d);\n            return events;\n        }\n    },\n    member: function (node, context) {\n        var e_2, _a;\n        var _b, _c, _d, _e;\n        var ts = context.ts;\n        if (isExtensionInterface(node, context, \"HTMLElement\")) {\n            var members = [];\n            var _loop_1 = function (member) {\n                if (ts.isPropertySignature(member)) {\n                    var name_2 = (_b = resolveNodeValue(member.name, context)) === null || _b === void 0 ? void 0 : _b.value;\n                    if (name_2 != null && typeof name_2 === \"string\") {\n                        members.push({\n                            priority: \"medium\",\n                            node: member,\n                            jsDoc: getJsDoc(member, ts),\n                            kind: \"property\",\n                            propName: name_2,\n                            type: lazy(function () { return context.checker.getTypeAtLocation(member); })\n                        });\n                    }\n                }\n            };\n            try {\n                for (var _f = __values(node.members), _g = _f.next(); !_g.done; _g = _f.next()) {\n                    var member = _g.value;\n                    _loop_1(member);\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (_g && !_g.done && (_a = _f.return)) _a.call(_f);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n            (_e = (_c = context) === null || _c === void 0 ? void 0 : (_d = _c).emitContinue) === null || _e === void 0 ? void 0 : _e.call(_d);\n            return members;\n        }\n    }\n};\n\n/**\n * Discovers inheritance from a node by looking at \"extends\" and \"implements\"\n * @param node\n * @param context\n */\nfunction discoverInheritance(node, context) {\n    var declarationKind = undefined;\n    var heritageClauses = [];\n    var declarationNodes = new Set();\n    // Resolve the structure of the node\n    resolveStructure(node, __assign(__assign({}, context), { emitDeclaration: function (decl) { return declarationNodes.add(decl); }, emitInheritance: function (kind, identifier) { return heritageClauses.push({ kind: kind, identifier: identifier, declaration: undefined }); }, emitDeclarationKind: function (kind) { return (declarationKind = declarationKind || kind); }, visitedNodes: new Set() }));\n    // Reverse heritage clauses because they come out in wrong order\n    heritageClauses.reverse();\n    return {\n        declarationNodes: Array.from(declarationNodes),\n        heritageClauses: heritageClauses,\n        declarationKind: declarationKind\n    };\n}\nfunction resolveStructure(node, context) {\n    var e_1, _a, e_2, _b, e_3, _c, e_4, _d;\n    var ts = context.ts;\n    if (context.visitedNodes.has(node)) {\n        return;\n    }\n    context.visitedNodes.add(node);\n    // Call this function recursively if this node is an identifier\n    if (ts.isIdentifier(node)) {\n        try {\n            for (var _e = __values(resolveDeclarationsDeep(node, context)), _f = _e.next(); !_f.done; _f = _e.next()) {\n                var decl = _f.value;\n                resolveStructure(decl, context);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_f && !_f.done && (_a = _e.return)) _a.call(_e);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    }\n    // Emit declaration node if we've found a class of interface\n    else if (ts.isClassLike(node) || ts.isInterfaceDeclaration(node)) {\n        context.emitDeclarationKind(ts.isClassLike(node) ? \"class\" : \"interface\");\n        context.emitDeclaration(node);\n        try {\n            // Resolve inheritance\n            for (var _g = __values(node.heritageClauses || []), _h = _g.next(); !_h.done; _h = _g.next()) {\n                var heritage = _h.value;\n                try {\n                    for (var _j = (e_3 = void 0, __values(heritage.types || [])), _k = _j.next(); !_k.done; _k = _j.next()) {\n                        var type = _k.value;\n                        resolveHeritage(heritage, type.expression, context);\n                    }\n                }\n                catch (e_3_1) { e_3 = { error: e_3_1 }; }\n                finally {\n                    try {\n                        if (_k && !_k.done && (_c = _j.return)) _c.call(_j);\n                    }\n                    finally { if (e_3) throw e_3.error; }\n                }\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (_h && !_h.done && (_b = _g.return)) _b.call(_g);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n    }\n    // Emit a declaration node if this node is a type literal\n    else if (ts.isTypeLiteralNode(node) || ts.isObjectLiteralExpression(node)) {\n        context.emitDeclarationKind(\"interface\");\n        context.emitDeclaration(node);\n    }\n    // Emit a mixin if this node is a function\n    else if (ts.isFunctionLike(node)) {\n        context.emitDeclarationKind(\"mixin\");\n        // Else find the first class declaration in the block\n        // Note that we don't look for a return statement because this would complicate things\n        var clzDecl = findChild(node, ts.isClassLike);\n        if (clzDecl != null) {\n            resolveStructure(clzDecl, context);\n            return;\n        }\n        // If we didn't find any class declarations, we might be in a function that wraps a mixin\n        // Therefore find the return statement and call this method recursively\n        var returnNode = findChild(node, ts.isReturnStatement);\n        if (returnNode != null && returnNode.expression != null && returnNode.expression !== node) {\n            var returnNodeExp = returnNode.expression;\n            // If a function call is returned, this function call expression is followed, and the arguments are treated as heritage\n            //    Example: return MyFirstMixin(MySecondMixin(Base))   -->   MyFirstMixin is followed, and MySecondMixin + Base are inherited\n            if (ts.isCallExpression(returnNodeExp) && returnNodeExp.expression != null) {\n                try {\n                    for (var _l = __values(returnNodeExp.arguments), _m = _l.next(); !_m.done; _m = _l.next()) {\n                        var arg = _m.value;\n                        resolveHeritage(undefined, arg, context);\n                    }\n                }\n                catch (e_4_1) { e_4 = { error: e_4_1 }; }\n                finally {\n                    try {\n                        if (_m && !_m.done && (_d = _l.return)) _d.call(_l);\n                    }\n                    finally { if (e_4) throw e_4.error; }\n                }\n                resolveStructure(returnNodeExp.expression, context);\n            }\n            return;\n        }\n    }\n    // Find any identifiers if the node is in a declaration file\n    else if (node.getSourceFile().isDeclarationFile) {\n        findChildren(node, ts.isIdentifier, function (identifier) {\n            resolveStructure(identifier, context);\n        });\n    }\n    // Handle variable declarations that are assigned to functions (mixins)\n    else if (ts.isVariableDeclaration(node)) {\n        var functionDecl = findChild(node.initializer, ts.isFunctionLike);\n        if (functionDecl != null) {\n            resolveStructure(functionDecl, context);\n        }\n    }\n}\nfunction resolveHeritage(heritage, node, context) {\n    var e_5, _a, e_6, _b;\n    var _c;\n    var ts = context.ts;\n    /**\n     * Parse mixins\n     */\n    if (ts.isCallExpression(node)) {\n        // Mixins\n        var identifier = node.expression, args = node.arguments;\n        try {\n            // Extend classes given to the mixin\n            // Example: class MyElement extends MyMixin(MyBase) --> MyBase\n            // Example: class MyElement extends MyMixin(MyBase1, MyBase2) --> MyBase1, MyBase2\n            for (var args_1 = __values(args), args_1_1 = args_1.next(); !args_1_1.done; args_1_1 = args_1.next()) {\n                var arg = args_1_1.value;\n                resolveHeritage(heritage, arg, context);\n            }\n        }\n        catch (e_5_1) { e_5 = { error: e_5_1 }; }\n        finally {\n            try {\n                if (args_1_1 && !args_1_1.done && (_a = args_1.return)) _a.call(args_1);\n            }\n            finally { if (e_5) throw e_5.error; }\n        }\n        // Resolve and traverse the mixin function\n        // Example: class MyElement extends MyMixin(MyBase) --> MyMixin\n        if (identifier != null && ts.isIdentifier(identifier)) {\n            resolveHeritage(\"mixin\", identifier, context);\n        }\n    }\n    else if (ts.isIdentifier(node)) {\n        // Try to handle situation like this, by resolving the variable in between\n        //    const Base = ExtraMixin(base);\n        //    class MixinClass extends Base { }\n        var dontEmitHeritageClause = false;\n        // Resolve the declaration of this identifier\n        var declarations = resolveDeclarationsDeep(node, context);\n        var _loop_1 = function (decl) {\n            // If the resolved declaration is a variable declaration assigned to a function, try to follow the assignments.\n            //    Example:    const MyBase = MyMixin(Base); return class extends MyBase { ... }\n            if (context.ts.isVariableDeclaration(decl) && decl.initializer != null) {\n                if (context.ts.isCallExpression(decl.initializer)) {\n                    var hasDeclaration_1 = false;\n                    resolveStructure(decl, __assign(__assign({}, context), { emitInheritance: function () { }, emitDeclarationKind: function () { }, emitDeclaration: function () {\n                            hasDeclaration_1 = true;\n                        } }));\n                    if (!hasDeclaration_1) {\n                        resolveHeritage(heritage, decl.initializer, context);\n                        dontEmitHeritageClause = true;\n                    }\n                }\n            }\n            // Don't emit inheritance if it's a parameter, because the parameter\n            //    is a subsitution for the actual base class which we have already resolved.\n            else if (context.ts.isParameter(decl)) {\n                dontEmitHeritageClause = true;\n            }\n        };\n        try {\n            for (var declarations_1 = __values(declarations), declarations_1_1 = declarations_1.next(); !declarations_1_1.done; declarations_1_1 = declarations_1.next()) {\n                var decl = declarations_1_1.value;\n                _loop_1(decl);\n            }\n        }\n        catch (e_6_1) { e_6 = { error: e_6_1 }; }\n        finally {\n            try {\n                if (declarations_1_1 && !declarations_1_1.done && (_b = declarations_1.return)) _b.call(declarations_1);\n            }\n            finally { if (e_6) throw e_6.error; }\n        }\n        if (!dontEmitHeritageClause) {\n            // This is an \"implements\" clause if implement keyword is used or if all the resolved declarations are interfaces\n            var kind = heritage != null && typeof heritage === \"string\"\n                ? heritage\n                : ((_c = heritage) === null || _c === void 0 ? void 0 : _c.token) === ts.SyntaxKind.ImplementsKeyword ||\n                    (declarations.length > 0 && !declarations.some(function (decl) { return !context.ts.isInterfaceDeclaration(decl); }))\n                    ? \"implements\"\n                    : \"extends\";\n            context.emitInheritance(kind, node);\n        }\n    }\n}\n\n/**\n * Relax the type so that for example \"string literal\" become \"string\" and \"function\" become \"any\"\n * This is used for javascript files to provide type checking with Typescript type inferring\n * @param type\n */\nfunction relaxType(type) {\n    switch (type.kind) {\n        case ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].INTERSECTION:\n        case ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].UNION:\n            return __assign(__assign({}, type), { types: type.types.map(function (t) { return relaxType(t); }) });\n        case ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].ENUM:\n            return __assign(__assign({}, type), { types: type.types.map(function (t) { return relaxType(t); }) });\n        case ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].ARRAY:\n            return __assign(__assign({}, type), { type: relaxType(type.type) });\n        case ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].PROMISE:\n            return __assign(__assign({}, type), { type: relaxType(type.type) });\n        case ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].OBJECT:\n            return {\n                name: type.name,\n                kind: ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].OBJECT\n            };\n        case ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].INTERFACE:\n        case ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].FUNCTION:\n        case ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].CLASS:\n            return {\n                name: type.name,\n                kind: ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].ANY\n            };\n        case ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].NUMBER_LITERAL:\n            return { kind: ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].NUMBER };\n        case ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].STRING_LITERAL:\n            return { kind: ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].STRING };\n        case ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].BOOLEAN_LITERAL:\n            return { kind: ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].BOOLEAN };\n        case ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].BIG_INT_LITERAL:\n            return { kind: ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].BIG_INT };\n        case ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].ENUM_MEMBER:\n            return __assign(__assign({}, type), { type: relaxType(type.type) });\n        case ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].ALIAS:\n            return __assign(__assign({}, type), { target: relaxType(type.target) });\n        case ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].NULL:\n        case ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].UNDEFINED:\n            return { kind: ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].ANY };\n        default:\n            return type;\n    }\n}\n\n/**\n * Discovers members based on standard vanilla custom element rules\n * @param node\n * @param context\n */\nfunction discoverMembers(node, context) {\n    var e_1, _a, e_2, _b;\n    var _c, _d, _e, _f;\n    var ts = context.ts, checker = context.checker;\n    // Never pick up members not declared directly on the declaration node being traversed\n    if (node.parent !== context.declarationNode) {\n        return undefined;\n    }\n    // static get observedAttributes() { return ['c', 'l']; }\n    if (ts.isGetAccessor(node) && hasModifier(node, ts.SyntaxKind.StaticKeyword)) {\n        if (node.name.getText() === \"observedAttributes\" && node.body != null) {\n            var members = [];\n            // Find either the first \"return\" statement or the first \"array literal expression\"\n            var arrayLiteralExpression = (_d = (_c = node.body.statements.find(function (statement) { return ts.isReturnStatement(statement); })) === null || _c === void 0 ? void 0 : _c.expression, (_d !== null && _d !== void 0 ? _d : node.body.statements.find(function (statement) { return ts.isArrayLiteralExpression(statement); })));\n            if (arrayLiteralExpression != null && ts.isArrayLiteralExpression(arrayLiteralExpression)) {\n                try {\n                    // Emit an attribute for each string literal in the array.\n                    for (var _g = __values(arrayLiteralExpression.elements), _h = _g.next(); !_h.done; _h = _g.next()) {\n                        var attrNameNode = _h.value;\n                        var attrName = ts.isStringLiteralLike(attrNameNode) ? attrNameNode.text : undefined;\n                        if (attrName == null)\n                            continue;\n                        members.push({\n                            priority: \"medium\",\n                            node: attrNameNode,\n                            jsDoc: getJsDoc(attrNameNode, ts),\n                            kind: \"attribute\",\n                            attrName: attrName,\n                            type: undefined // () => ({ kind: SimpleTypeKind.ANY } as SimpleType),\n                        });\n                    }\n                }\n                catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                finally {\n                    try {\n                        if (_h && !_h.done && (_a = _g.return)) _a.call(_g);\n                    }\n                    finally { if (e_1) throw e_1.error; }\n                }\n            }\n            return members;\n        }\n    }\n    // class { myProp = \"hello\"; }\n    else if (ts.isPropertyDeclaration(node) || ts.isPropertySignature(node)) {\n        var name_1 = node.name, initializer = node.initializer;\n        if (ts.isIdentifier(name_1) || ts.isStringLiteralLike(name_1)) {\n            // Find default value based on initializer\n            var resolvedDefaultValue = initializer != null ? resolveNodeValue(initializer, context) : undefined;\n            var def = resolvedDefaultValue != null ? resolvedDefaultValue.value : (_e = initializer) === null || _e === void 0 ? void 0 : _e.getText();\n            return [\n                {\n                    priority: \"high\",\n                    node: node,\n                    kind: \"property\",\n                    jsDoc: getJsDoc(node, ts),\n                    propName: name_1.text,\n                    type: lazy(function () { return checker.getTypeAtLocation(node); }),\n                    default: def,\n                    visibility: getMemberVisibilityFromNode(node, ts),\n                    modifiers: getModifiersFromNode(node, ts)\n                    //required: isPropertyRequired(node, context.checker),\n                }\n            ];\n        }\n    }\n    // class { set myProp(value: string) { ... } }\n    else if (ts.isSetAccessor(node) || ts.isGetAccessor(node)) {\n        var name_2 = node.name, parameters = node.parameters;\n        if (ts.isIdentifier(name_2)) {\n            var parameter_1 = ts.isSetAccessor(node) != null && ((_f = parameters) === null || _f === void 0 ? void 0 : _f.length) > 0 ? parameters[0] : undefined;\n            return [\n                {\n                    priority: \"high\",\n                    node: node,\n                    jsDoc: getJsDoc(node, ts),\n                    kind: \"property\",\n                    propName: name_2.text,\n                    type: lazy(function () { return (parameter_1 == null ? context.checker.getTypeAtLocation(node) : context.checker.getTypeAtLocation(parameter_1)); }),\n                    visibility: getMemberVisibilityFromNode(node, ts),\n                    modifiers: getModifiersFromNode(node, ts)\n                }\n            ];\n        }\n    }\n    // constructor { super(); this.title = \"Hello\"; }\n    else if (ts.isConstructorDeclaration(node)) {\n        if (node.body != null) {\n            var assignments = node.body.statements\n                .filter(function (stmt) { return ts.isExpressionStatement(stmt); })\n                .map(function (stmt) { return stmt.expression; })\n                .filter(function (exp) { return ts.isBinaryExpression(exp); });\n            var members = [];\n            var _loop_1 = function (assignment) {\n                var left = assignment.left, right = assignment.right;\n                if (ts.isPropertyAccessExpression(left)) {\n                    if (left.expression.kind === ts.SyntaxKind.ThisKeyword) {\n                        var propName = left.name.getText();\n                        var resolvedInitializer = resolveNodeValue(right, context);\n                        var def = resolvedInitializer != null ? resolvedInitializer.value : undefined; //right.getText();\n                        members.push({\n                            priority: \"low\",\n                            node: node,\n                            kind: \"property\",\n                            propName: propName,\n                            default: def,\n                            type: function () { return relaxType(Object(ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"toSimpleType\"])(checker.getTypeAtLocation(right), checker)); },\n                            jsDoc: getJsDoc(assignment.parent, ts),\n                            visibility: isNamePrivate(propName) ? \"private\" : undefined\n                        });\n                    }\n                }\n            };\n            try {\n                for (var assignments_1 = __values(assignments), assignments_1_1 = assignments_1.next(); !assignments_1_1.done; assignments_1_1 = assignments_1.next()) {\n                    var assignment = assignments_1_1.value;\n                    _loop_1(assignment);\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (assignments_1_1 && !assignments_1_1.done && (_b = assignments_1.return)) _b.call(assignments_1);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n            return members;\n        }\n    }\n    return undefined;\n}\n\n/**\n * Discovers methods\n * @param node\n * @param context\n */\nfunction discoverMethods(node, context) {\n    var _a, _b;\n    var ts = context.ts;\n    // Never pick up method declaration not declared directly on the declaration node being traversed\n    if (node.parent !== context.declarationNode) {\n        return undefined;\n    }\n    // class { myMethod () {} }\n    if ((ts.isMethodDeclaration(node) || ts.isMethodSignature(node)) && !hasModifier(node, ts.SyntaxKind.StaticKeyword)) {\n        // Outscope static methods for now\n        var name_1 = node.name.getText();\n        if (!context.config.analyzeDefaultLib && isHTMLElementMethodName(name_1)) {\n            return undefined;\n        }\n        // Allow the analyzer to analyze within methods\n        (_b = (_a = context).emitContinue) === null || _b === void 0 ? void 0 : _b.call(_a);\n        return [\n            {\n                jsDoc: getJsDoc(node, ts),\n                name: name_1,\n                node: node,\n                visibility: getMemberVisibilityFromNode(node, ts),\n                type: lazy(function () { return context.checker.getTypeAtLocation(node); })\n            }\n        ];\n    }\n    return undefined;\n}\nfunction isHTMLElementMethodName(name) {\n    return [\"attributeChangedCallback\", \"connectedCallback\", \"disconnectedCallback\"].includes(name);\n}\n\n/**\n * Excludes nodes from \"lib.dom.d.ts\" if analyzeLibDom is false\n * @param node\n * @param context\n */\nfunction excludeNode(node, context) {\n    if (context.config.analyzeDefaultLib) {\n        return undefined;\n    }\n    return isLibDom(node);\n}\nfunction isLibDom(node) {\n    return node.getSourceFile().fileName.endsWith(\"lib.dom.d.ts\");\n}\n\n/**\n * A flavor that discovers using standard custom element rules\n */\nvar CustomElementFlavor = /** @class */ (function () {\n    function CustomElementFlavor() {\n        this.excludeNode = excludeNode;\n        this.discoverDefinitions = discoverDefinitions;\n        this.discoverFeatures = {\n            member: discoverMembers,\n            event: discoverEvents,\n            method: discoverMethods\n        };\n        this.discoverGlobalFeatures = discoverGlobalFeatures;\n        this.discoverInheritance = discoverInheritance;\n    }\n    return CustomElementFlavor;\n}());\n\n/**\n * Transforms jsdoc tags to a T array using a \"transform\"\n * @param node\n * @param tagNames\n * @param transform\n * @param context\n */\nfunction parseJsDocForNode(node, tagNames, transform, context) {\n    var _a, _b;\n    var tags = (getJsDoc(node, tagNames, context.ts) || {}).tags;\n    if (tags != null && tags.length > 0) {\n        (_b = (_a = context).emitContinue) === null || _b === void 0 ? void 0 : _b.call(_a);\n        return arrayDefined(tags.map(function (tag) { return transform(tag.node, tag.parsed()); }));\n    }\n    return undefined;\n}\n\n/**\n * Discovers definitions using \"@customElement\" or \"@element\" jsdoc\n * @param node\n * @param context\n */\nfunction discoverDefinitions$1(node, context) {\n    // /** @customElement my-element */ myClass extends HTMLElement { ... }\n    if (context.ts.isInterfaceDeclaration(node) || context.ts.isClassDeclaration(node)) {\n        var identifier_1 = getNodeIdentifier(node, context);\n        return parseJsDocForNode(node, [\"customelement\", \"element\"], function (tagNode, _a) {\n            var name = _a.name;\n            return {\n                tagName: name || \"\",\n                definitionNode: tagNode,\n                identifierNode: identifier_1\n            };\n        }, context);\n    }\n}\n\nvar discoverFeatures = {\n    csspart: function (node, context) {\n        if (context.ts.isInterfaceDeclaration(node) || context.ts.isClassDeclaration(node)) {\n            return parseJsDocForNode(node, [\"csspart\"], function (tagNode, _a) {\n                var name = _a.name, description = _a.description;\n                if (name != null && name.length > 0) {\n                    return {\n                        name: name,\n                        jsDoc: description != null ? { description: description } : undefined\n                    };\n                }\n            }, context);\n        }\n    },\n    cssproperty: function (node, context) {\n        if (context.ts.isInterfaceDeclaration(node) || context.ts.isClassDeclaration(node)) {\n            return parseJsDocForNode(node, [\"cssprop\", \"cssproperty\", \"cssvar\", \"cssvariable\"], function (tagNode, _a) {\n                var name = _a.name, description = _a.description, type = _a.type, def = _a.default;\n                if (name != null && name.length > 0) {\n                    return {\n                        name: name,\n                        jsDoc: description != null ? { description: description } : undefined,\n                        typeHint: type || undefined,\n                        default: def\n                    };\n                }\n            }, context);\n        }\n    },\n    event: function (node, context) {\n        if (context.ts.isInterfaceDeclaration(node) || context.ts.isClassDeclaration(node)) {\n            return parseJsDocForNode(node, [\"event\", \"fires\", \"emits\"], function (tagNode, _a) {\n                var name = _a.name, description = _a.description, type = _a.type;\n                if (name != null && name.length > 0 && tagNode != null) {\n                    return {\n                        name: name,\n                        jsDoc: description != null ? { description: description } : undefined,\n                        type: lazy(function () { return (type && parseSimpleJsDocTypeExpression(type)) || { kind: ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].ANY }; }),\n                        typeHint: type,\n                        node: tagNode\n                    };\n                }\n            }, context);\n        }\n    },\n    slot: function (node, context) {\n        if (context.ts.isInterfaceDeclaration(node) || context.ts.isClassDeclaration(node)) {\n            return parseJsDocForNode(node, [\"slot\"], function (tagNode, _a) {\n                var name = _a.name, type = _a.type, description = _a.description;\n                // Grab the type from jsdoc and use it to find permitted tag names\n                // Example: @slot {\"div\"|\"span\"} myslot\n                var permittedTagNameType = type == null ? undefined : parseSimpleJsDocTypeExpression(type);\n                var permittedTagNames = (function () {\n                    if (permittedTagNameType == null) {\n                        return undefined;\n                    }\n                    switch (permittedTagNameType.kind) {\n                        case ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].STRING_LITERAL:\n                            return [permittedTagNameType.value];\n                        case ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].UNION:\n                            return permittedTagNameType.types\n                                .filter(function (type) { return type.kind === ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].STRING_LITERAL; })\n                                .map(function (type) { return type.value; });\n                        default:\n                            return undefined;\n                    }\n                })();\n                return {\n                    name: name,\n                    jsDoc: description != null ? { description: description } : undefined,\n                    permittedTagNames: permittedTagNames\n                };\n            }, context);\n        }\n    },\n    member: function (node, context) {\n        if (context.ts.isInterfaceDeclaration(node) || context.ts.isClassDeclaration(node)) {\n            var priority_1 = getNodeSourceFileLang(node) === \"js\" ? \"high\" : \"medium\";\n            var properties = parseJsDocForNode(node, [\"prop\", \"property\"], function (tagNode, _a) {\n                var name = _a.name, def = _a.default, type = _a.type, description = _a.description;\n                if (name != null && name.length > 0) {\n                    return {\n                        priority: priority_1,\n                        kind: \"property\",\n                        propName: name,\n                        jsDoc: description != null ? { description: description } : undefined,\n                        typeHint: type,\n                        type: lazy(function () { return (type && parseSimpleJsDocTypeExpression(type)) || { kind: ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].ANY }; }),\n                        node: tagNode,\n                        default: def,\n                        visibility: undefined,\n                        reflect: undefined,\n                        required: undefined,\n                        deprecated: undefined\n                    };\n                }\n            }, context);\n            var attributes = parseJsDocForNode(node, [\"attr\", \"attribute\"], function (tagNode, _a) {\n                var name = _a.name, def = _a.default, type = _a.type, description = _a.description;\n                if (name != null && name.length > 0) {\n                    return {\n                        priority: priority_1,\n                        kind: \"attribute\",\n                        attrName: name,\n                        jsDoc: description != null ? { description: description } : undefined,\n                        type: lazy(function () { return (type && parseSimpleJsDocTypeExpression(type)) || { kind: ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].ANY }; }),\n                        typeHint: type,\n                        node: tagNode,\n                        default: def,\n                        visibility: undefined,\n                        reflect: undefined,\n                        required: undefined,\n                        deprecated: undefined\n                    };\n                }\n            }, context);\n            if (attributes != null || properties != null) {\n                return __spread((attributes || []), (properties || []));\n            }\n            return undefined;\n        }\n    }\n};\n\nvar discoverGlobalFeatures$1 = {\n    csspart: function (node, context) {\n        var _a, _b;\n        if (isExtensionInterface(node, context, \"HTMLElement\")) {\n            return (_b = (_a = discoverFeatures).csspart) === null || _b === void 0 ? void 0 : _b.call(_a, node, context);\n        }\n    },\n    cssproperty: function (node, context) {\n        var _a, _b;\n        if (isExtensionInterface(node, context, \"HTMLElement\")) {\n            return (_b = (_a = discoverFeatures).cssproperty) === null || _b === void 0 ? void 0 : _b.call(_a, node, context);\n        }\n    },\n    event: function (node, context) {\n        var _a, _b;\n        if (isExtensionInterface(node, context, \"HTMLElement\")) {\n            return (_b = (_a = discoverFeatures).event) === null || _b === void 0 ? void 0 : _b.call(_a, node, context);\n        }\n    },\n    slot: function (node, context) {\n        var _a, _b;\n        if (isExtensionInterface(node, context, \"HTMLElement\")) {\n            return (_b = (_a = discoverFeatures).slot) === null || _b === void 0 ? void 0 : _b.call(_a, node, context);\n        }\n    },\n    member: function (node, context) {\n        var _a, _b, _c;\n        if (isExtensionInterface(node, context, \"HTMLElement\")) {\n            return (_c = (_a = discoverFeatures) === null || _a === void 0 ? void 0 : (_b = _a).member) === null || _c === void 0 ? void 0 : _c.call(_b, node, context);\n        }\n    }\n};\n\n/**\n * Refines a component declaration by using jsdoc tags\n * @param declaration\n * @param context\n */\nfunction refineDeclaration(declaration, context) {\n    if (declaration.jsDoc == null || declaration.jsDoc.tags == null) {\n        return undefined;\n    }\n    // Applies the \"@deprecated\" jsdoc tag\n    var deprecatedTag = declaration.jsDoc.tags.find(function (t) { return t.tag === \"deprecated\"; });\n    if (deprecatedTag != null) {\n        return __assign(__assign({}, declaration), { deprecated: deprecatedTag.comment || true });\n    }\n    return undefined;\n}\n\n/**\n * Refines features by looking at the jsdoc tags on the feature\n */\nvar refineFeature = {\n    event: function (event) {\n        if (event.jsDoc == null || event.jsDoc.tags == null)\n            return event;\n        // Check if the feature has \"@ignore\" jsdoc tag\n        if (hasIgnoreJsDocTag(event.jsDoc)) {\n            return undefined;\n        }\n        return [applyJsDocDeprecated, applyJsDocVisibility, applyJsDocType].reduce(function (event, applyFunc) { return applyFunc(event, event.jsDoc); }, event);\n    },\n    method: function (method) {\n        if (method.jsDoc == null || method.jsDoc.tags == null)\n            return method;\n        // Check if the feature has \"@ignore\" jsdoc tag\n        if (hasIgnoreJsDocTag(method.jsDoc)) {\n            return undefined;\n        }\n        method = [applyJsDocDeprecated, applyJsDocVisibility].reduce(function (method, applyFunc) { return applyFunc(method, method.jsDoc); }, method);\n        return method;\n    },\n    member: function (member) {\n        // Return right away if the member doesn't have jsdoc\n        if (member.jsDoc == null || member.jsDoc.tags == null)\n            return member;\n        // Check if the feature has \"@ignore\" jsdoc tag\n        if (hasIgnoreJsDocTag(member.jsDoc)) {\n            return undefined;\n        }\n        return [\n            applyJsDocDeprecated,\n            applyJsDocVisibility,\n            applyJsDocRequired,\n            applyJsDocDefault,\n            applyJsDocReflect,\n            applyJsDocType,\n            applyJsDocAttribute,\n            applyJsDocModifiers\n        ].reduce(function (member, applyFunc) { return applyFunc(member, member.jsDoc); }, member);\n    }\n};\n/**\n * Applies the \"@deprecated\" jsdoc tag\n * @param feature\n * @param jsDoc\n */\nfunction applyJsDocDeprecated(feature, jsDoc) {\n    var _a;\n    var deprecatedTag = (_a = jsDoc.tags) === null || _a === void 0 ? void 0 : _a.find(function (tag) { return tag.tag === \"deprecated\"; });\n    if (deprecatedTag != null) {\n        return __assign(__assign({}, feature), { deprecated: deprecatedTag.comment || true });\n    }\n    return feature;\n}\n/**\n * Applies the \"@access\" jsdoc tag\n * @param feature\n * @param jsDoc\n */\nfunction applyJsDocVisibility(feature, jsDoc) {\n    var _a;\n    var visibilityTag = (_a = jsDoc.tags) === null || _a === void 0 ? void 0 : _a.find(function (tag) { return [\"public\", \"protected\", \"private\", \"package\", \"access\"].includes(tag.tag); }); // member + method\n    if (visibilityTag != null) {\n        return __assign(__assign({}, feature), { visibility: (function () {\n                switch (visibilityTag.tag) {\n                    case \"public\":\n                        return \"public\";\n                    case \"protected\":\n                        return \"protected\";\n                    case \"package\":\n                    case \"private\":\n                        return \"private\";\n                    case \"access\":\n                        switch (visibilityTag.parsed().name) {\n                            case \"public\":\n                                return \"public\";\n                            case \"protected\":\n                                return \"protected\";\n                            case \"private\":\n                            case \"package\":\n                                return \"private\";\n                            default:\n                                return undefined;\n                        }\n                    default:\n                        return undefined;\n                }\n            })() });\n    }\n    return feature;\n}\n/**\n * Applies the \"@attribute\" jsdoc tag\n * @param feature\n * @param jsDoc\n */\nfunction applyJsDocAttribute(feature, jsDoc) {\n    var _a, _b, _c;\n    var attributeTag = (_a = jsDoc.tags) === null || _a === void 0 ? void 0 : _a.find(function (tag) { return [\"attr\", \"attribute\"].includes(tag.tag); });\n    if (attributeTag != null && feature.attrName == null) {\n        var parsed_1 = attributeTag.parsed();\n        var result = __assign(__assign({}, feature), { attrName: attributeTag.parsed().name || feature.propName, default: (_b = feature.default, (_b !== null && _b !== void 0 ? _b : parsed_1.default)) });\n        // @attr jsdoc tag can also include the type of attribute\n        if (parsed_1.type != null && result.typeHint == null) {\n            result.typeHint = parsed_1.type;\n            result.type = (_c = feature.type, (_c !== null && _c !== void 0 ? _c : lazy(function () { return parseSimpleJsDocTypeExpression(parsed_1.type || \"\"); })));\n        }\n        return result;\n    }\n    return feature;\n}\n/**\n * Applies the \"@required\" jsdoc tag\n * @param feature\n * @param jsDoc\n */\nfunction applyJsDocRequired(feature, jsDoc) {\n    var _a;\n    var requiredTag = (_a = jsDoc.tags) === null || _a === void 0 ? void 0 : _a.find(function (tag) { return [\"optional\", \"required\"].includes(tag.tag); });\n    if (requiredTag != null) {\n        return __assign(__assign({}, feature), { required: requiredTag.tag === \"required\" });\n    }\n    return feature;\n}\n/**\n * Applies the \"@readonly\" jsdoc tag\n * @param feature\n * @param jsDoc\n */\nfunction applyJsDocModifiers(feature, jsDoc) {\n    var _a;\n    var readonlyTag = (_a = jsDoc.tags) === null || _a === void 0 ? void 0 : _a.find(function (tag) { return tag.tag === \"readonly\"; });\n    if (readonlyTag != null) {\n        return __assign(__assign({}, feature), { modifiers: (feature.modifiers != null ? new Set(feature.modifiers) : new Set()).add(\"readonly\") });\n    }\n    return feature;\n}\n/**\n * Applies the \"@default\" jsdoc tag\n * @param feature\n * @param jsDoc\n */\nfunction applyJsDocDefault(feature, jsDoc) {\n    var _a;\n    var defaultTag = (_a = jsDoc.tags) === null || _a === void 0 ? void 0 : _a.find(function (tag) { return tag.tag === \"default\"; });\n    if (defaultTag != null) {\n        return __assign(__assign({}, feature), { default: defaultTag.comment });\n    }\n    return feature;\n}\n/**\n * Applies the \"@reflect\" jsdoc tag\n * @param feature\n * @param jsDoc\n */\nfunction applyJsDocReflect(feature, jsDoc) {\n    var _a;\n    var reflectTag = (_a = jsDoc.tags) === null || _a === void 0 ? void 0 : _a.find(function (tag) { return tag.tag === \"reflect\"; });\n    if (reflectTag != null && feature.reflect == null) {\n        return __assign(__assign({}, feature), { reflect: (function () {\n                switch (reflectTag.comment) {\n                    case \"to-attribute\":\n                        return \"to-attribute\";\n                    case \"to-property\":\n                        return \"to-property\";\n                    case \"both\":\n                        return \"both\";\n                    default:\n                        return undefined;\n                }\n            })() });\n    }\n    return feature;\n}\n/**\n * Applies the \"@type\" jsdoc tag\n * @param feature\n * @param jsDoc\n */\nfunction applyJsDocType(feature, jsDoc) {\n    var _a, _b;\n    var typeTag = (_a = jsDoc.tags) === null || _a === void 0 ? void 0 : _a.find(function (tag) { return tag.tag === \"type\"; });\n    if (typeTag != null && feature.typeHint == null) {\n        var parsed_2 = typeTag.parsed();\n        if (parsed_2.type != null && parsed_2.type.length > 0) {\n            return __assign(__assign({}, feature), { typeHint: parsed_2.type, type: (_b = feature.type, (_b !== null && _b !== void 0 ? _b : lazy(function () { return parseSimpleJsDocTypeExpression(parsed_2.type || \"\"); }))) });\n        }\n    }\n    return feature;\n}\n/**\n * Returns if jsdoc contains an ignore node\n * @param jsDoc\n */\nfunction hasIgnoreJsDocTag(jsDoc) {\n    var _a, _b;\n    return ((_b = (_a = jsDoc) === null || _a === void 0 ? void 0 : _a.tags) === null || _b === void 0 ? void 0 : _b.find(function (tag) { return tag.tag === \"ignore\"; })) != null;\n}\n\n/**\n * Flavors for analyzing jsdoc related features\n */\nvar JsDocFlavor = /** @class */ (function () {\n    function JsDocFlavor() {\n        this.discoverDefinitions = discoverDefinitions$1;\n        this.discoverFeatures = discoverFeatures;\n        this.discoverGlobalFeatures = discoverGlobalFeatures$1;\n        this.refineFeature = refineFeature;\n        this.refineDeclaration = refineDeclaration;\n    }\n    return JsDocFlavor;\n}());\n\n/**\n * Discovers element definitions in \"IntrinsicElements\"\n * @param node\n * @param context\n */\nfunction discoverDefinitions$2(node, context) {\n    var ts = context.ts;\n    if (ts.isInterfaceDeclaration(node)) {\n        if (node.name.text === \"IntrinsicElements\") {\n            var extensions = getInterfaceKeys(node, context);\n            return extensions.map(function (_a) {\n                var key = _a.key, keyNode = _a.keyNode, identifier = _a.identifier, declaration = _a.declaration;\n                return ({\n                    tagName: key,\n                    tagNameNode: keyNode,\n                    identifierNode: identifier,\n                    declarationNode: declaration\n                });\n            });\n        }\n    }\n    return undefined;\n}\n\n/**\n * Discovers members declared on \"IntrinsicAttributes\"\n */\nvar discoverGlobalFeatures$2 = {\n    member: function (node, context) {\n        var e_1, _a;\n        var _b, _c, _d, _e;\n        var ts = context.ts;\n        if (ts.isInterfaceDeclaration(node) && node.name.text === \"IntrinsicAttributes\") {\n            var members = [];\n            var _loop_1 = function (member) {\n                if (ts.isPropertySignature(member)) {\n                    var name_1 = (_b = resolveNodeValue(member.name, context)) === null || _b === void 0 ? void 0 : _b.value;\n                    if (name_1 != null && typeof name_1 === \"string\") {\n                        members.push({\n                            priority: \"medium\",\n                            node: member,\n                            jsDoc: getJsDoc(member, ts),\n                            kind: \"property\",\n                            propName: name_1,\n                            attrName: name_1,\n                            type: function () { return context.checker.getTypeAtLocation(member); }\n                        });\n                    }\n                }\n            };\n            try {\n                for (var _f = __values(node.members), _g = _f.next(); !_g.done; _g = _f.next()) {\n                    var member = _g.value;\n                    _loop_1(member);\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (_g && !_g.done && (_a = _f.return)) _a.call(_f);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            (_e = (_c = context) === null || _c === void 0 ? void 0 : (_d = _c).emitContinue) === null || _e === void 0 ? void 0 : _e.call(_d);\n            return members;\n        }\n    }\n};\n\n/**\n * Flavors for analyzing jsx related features\n */\nvar JSXFlavor = /** @class */ (function () {\n    function JSXFlavor() {\n        this.discoverDefinitions = discoverDefinitions$2;\n        this.discoverGlobalFeatures = discoverGlobalFeatures$2;\n    }\n    return JSXFlavor;\n}());\n\n/**\n * Visits lit-element related definitions.\n * Specifically it finds the usage of the @customElement decorator.\n * @param node\n * @param context\n */\nfunction discoverDefinitions$3(node, context) {\n    var e_1, _a;\n    var ts = context.ts, checker = context.checker;\n    // @customElement(\"my-element\")\n    if (ts.isClassDeclaration(node)) {\n        try {\n            // Visit all decorators on the class\n            for (var _b = __values(node.decorators || []), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var decorator = _c.value;\n                var callExpression = decorator.expression;\n                // Find \"@customElement\"\n                if (ts.isCallExpression(callExpression) && ts.isIdentifier(callExpression.expression)) {\n                    var decoratorIdentifierName = callExpression.expression.escapedText;\n                    // Decorators called \"customElement\"\n                    if (decoratorIdentifierName === \"customElement\") {\n                        // Resolve the value of the first argument. This is the tag name.\n                        var unresolvedTagNameNode = callExpression.arguments[0];\n                        var resolvedTagNameNode = resolveNodeValue(unresolvedTagNameNode, { ts: ts, checker: checker });\n                        var identifier = getNodeIdentifier(node, context);\n                        if (resolvedTagNameNode != null && typeof resolvedTagNameNode.value === \"string\") {\n                            return [\n                                {\n                                    tagName: resolvedTagNameNode.value,\n                                    tagNameNode: resolvedTagNameNode.node,\n                                    identifierNode: identifier\n                                }\n                            ];\n                        }\n                    }\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return;\n    }\n    node.forEachChild(function (child) {\n        discoverDefinitions$3(child, context);\n    });\n}\n\nvar LIT_ELEMENT_PROPERTY_DECORATOR_KINDS = [\"property\", \"internalProperty\"];\n/**\n * Returns a potential lit element property decorator.\n * @param node\n * @param context\n */\nfunction getLitElementPropertyDecorator(node, context) {\n    var e_1, _a;\n    if (node.decorators == null)\n        return undefined;\n    var ts = context.ts;\n    try {\n        // Find a decorator with \"property\" name.\n        for (var _b = __values(node.decorators), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var decorator = _c.value;\n            var expression = decorator.expression;\n            // We find the first decorator calling specific identifier name (found in LIT_ELEMENT_PROPERTY_DECORATOR_KINDS)\n            if (ts.isCallExpression(expression) && ts.isIdentifier(expression.expression)) {\n                var identifier = expression.expression;\n                var kind = identifier.text;\n                if (LIT_ELEMENT_PROPERTY_DECORATOR_KINDS.includes(kind)) {\n                    return { expression: expression, kind: kind };\n                }\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n}\n/**\n * Returns a potential lit property decorator configuration.\n * @param node\n * @param context\n */\nfunction getLitElementPropertyDecoratorConfig(node, context) {\n    var ts = context.ts;\n    // Get reference to a possible \"@property\" decorator.\n    var decorator = getLitElementPropertyDecorator(node, context);\n    if (decorator != null) {\n        // Parse the first argument to the decorator which is the lit-property configuration.\n        var configNode = decorator.expression.arguments[0];\n        // Add decorator to \"nodes\"\n        var config = { node: { decorator: decorator.expression } };\n        // Apply specific config based on the decorator kind\n        switch (decorator.kind) {\n            case \"internalProperty\":\n                config.attribute = false;\n                break;\n        }\n        // Get lit options from the object literal expression\n        return configNode != null && ts.isObjectLiteralExpression(configNode) ? getLitPropertyOptions(configNode, context, config) : config;\n    }\n    return undefined;\n}\n/**\n * Parses an object literal expression and returns a lit property configuration.\n * @param node\n * @param existingConfig\n * @param context\n */\nfunction getLitPropertyOptions(node, context, existingConfig) {\n    if (existingConfig === void 0) { existingConfig = {}; }\n    var ts = context.ts;\n    // Build up the property configuration by looking at properties in the object literal expression\n    return node.properties.reduce(function (config, property) {\n        if (!ts.isPropertyAssignment(property))\n            return config;\n        var initializer = property.initializer;\n        var kind = ts.isIdentifier(property.name) ? property.name.text : undefined;\n        return parseLitPropertyOption({ kind: kind, initializer: initializer, config: config }, context);\n    }, existingConfig);\n}\nfunction parseLitPropertyOption(_a, context) {\n    var kind = _a.kind, initializer = _a.initializer, config = _a.config;\n    var _b, _c;\n    var ts = context.ts, checker = context.checker;\n    // noinspection DuplicateCaseLabelJS\n    switch (kind) {\n        case \"converter\": {\n            return __assign(__assign({}, config), { hasConverter: true });\n        }\n        case \"reflect\": {\n            return __assign(__assign({}, config), { reflect: ((_b = resolveNodeValue(initializer, context)) === null || _b === void 0 ? void 0 : _b.value) === true });\n        }\n        case \"attribute\": {\n            var attribute = void 0;\n            if (initializer.kind === ts.SyntaxKind.TrueKeyword) {\n                attribute = true;\n            }\n            else if (initializer.kind === ts.SyntaxKind.FalseKeyword) {\n                attribute = false;\n            }\n            else if (ts.isStringLiteral(initializer)) {\n                attribute = initializer.text;\n            }\n            return __assign(__assign({}, config), { attribute: attribute, node: __assign(__assign({}, (config.node || {})), { attribute: initializer }) });\n        }\n        case \"type\": {\n            var type = void 0;\n            var value = ts.isIdentifier(initializer) ? initializer.text : undefined;\n            switch (value) {\n                case \"String\":\n                case \"StringConstructor\":\n                    type = { kind: ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].STRING };\n                    break;\n                case \"Number\":\n                case \"NumberConstructor\":\n                    type = { kind: ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].NUMBER };\n                    break;\n                case \"Boolean\":\n                case \"BooleanConstructor\":\n                    type = { kind: ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].BOOLEAN };\n                    break;\n                case \"Array\":\n                case \"ArrayConstructor\":\n                    type = { kind: ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].ARRAY, type: { kind: ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].ANY } };\n                    break;\n                case \"Object\":\n                case \"ObjectConstructor\":\n                    type = { kind: ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].OBJECT, members: [] };\n                    break;\n                default:\n                    // This is an unknown type, so set the name as a string\n                    type = initializer.getText();\n                    break;\n            }\n            return __assign(__assign({}, config), { type: type, node: __assign(__assign({}, (config.node || {})), { type: initializer }) });\n        }\n        // Polymer specific field\n        case \"value\": {\n            return __assign(__assign({}, config), { default: (_c = resolveNodeValue(initializer, { ts: ts, checker: checker })) === null || _c === void 0 ? void 0 : _c.value });\n        }\n    }\n    return config;\n}\n\n/**\n * Parses lit-related declaration members.\n * This is primary by looking at the \"@property\" decorator and the \"static get properties()\".\n * @param node\n * @param context\n */\nfunction discoverMembers$1(node, context) {\n    var ts = context.ts;\n    // Never pick up members not declared directly on the declaration node being traversed\n    if (node.parent !== context.declarationNode) {\n        return undefined;\n    }\n    // static get properties() { return { myProp: {type: String} } }\n    if (ts.isGetAccessor(node) && hasModifier(node, ts.SyntaxKind.StaticKeyword)) {\n        var name_1 = node.name.getText();\n        if (name_1 === \"properties\" && node.body != null) {\n            var returnStatement = node.body.statements.find(ts.isReturnStatement.bind(ts));\n            if (returnStatement != null) {\n                return parseStaticProperties(returnStatement, context);\n            }\n        }\n    }\n    // @property({type: String}) myProp = \"hello\";\n    else if (ts.isSetAccessor(node) || ts.isGetAccessor(node) || ts.isPropertyDeclaration(node) || ts.isPropertySignature(node)) {\n        return parsePropertyDecorator(node, context);\n    }\n}\n/**\n * Visits a lit property decorator and returns members based on it.\n * @param node\n * @param context\n */\nfunction parsePropertyDecorator(node, context) {\n    var _a;\n    var ts = context.ts, checker = context.checker;\n    // Parse the content of a possible lit \"@property\" decorator.\n    var litConfig = getLitElementPropertyDecoratorConfig(node, context);\n    if (litConfig != null) {\n        var propName = node.name.getText();\n        // Get the attribute based on the configuration\n        var attrName = getLitAttributeName(propName, litConfig, context);\n        // Find the default value for this property\n        var initializer = \"initializer\" in node ? node.initializer : undefined;\n        var resolvedDefaultValue = initializer != null ? resolveNodeValue(initializer, context) : undefined;\n        var def = resolvedDefaultValue != null ? resolvedDefaultValue.value : (_a = initializer) === null || _a === void 0 ? void 0 : _a.getText();\n        // Find our if the property/attribute is required\n        //const required = (\"initializer\" in node && isPropertyRequired(node, context.checker)) || undefined;\n        var required = undefined;\n        var jsDoc = getJsDoc(node, ts);\n        // Emit a property with \"attrName\"\n        return [\n            {\n                priority: \"high\",\n                kind: \"property\",\n                propName: propName,\n                attrName: attrName,\n                type: lazy(function () {\n                    var propType = checker.getTypeAtLocation(node);\n                    var inJavascriptFile = getNodeSourceFileLang(node) === \"js\";\n                    return inJavascriptFile && typeof litConfig.type === \"object\" && litConfig.type.kind === ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].ANY ? litConfig.type : propType;\n                }),\n                node: node,\n                default: def,\n                required: required,\n                jsDoc: jsDoc,\n                meta: litConfig,\n                visibility: getMemberVisibilityFromNode(node, ts),\n                reflect: litConfig.reflect ? \"both\" : attrName != null ? \"to-property\" : undefined,\n                modifiers: getModifiersFromNode(node, ts)\n            }\n        ];\n    }\n    return undefined;\n}\n/**\n * Returns if we are in a Polymer context.\n * @param context\n */\nfunction inPolymerFlavorContext(context) {\n    var _a, _b, _c;\n    var declaration = context.getDeclaration();\n    // TODO: find a better way to construct a cache key\n    var cacheKey = \"isPolymerFlavorContext:\" + (((_a = context.sourceFile) === null || _a === void 0 ? void 0 : _a.fileName) || \"unknown\");\n    if (context.cache.general.has(cacheKey)) {\n        return context.cache.general.get(cacheKey);\n    }\n    var result = false;\n    // Use \"@polymer\" jsdoc tag to indicate that this is polymer context\n    if ((_c = (_b = declaration.jsDoc) === null || _b === void 0 ? void 0 : _b.tags) === null || _c === void 0 ? void 0 : _c.some(function (t) { return t.tag === \"polymer\" || t.tag === \"polymerElement\"; })) {\n        result = true;\n    }\n    // TODO: This only checks the immediate inheritance. Make it recursive to go throught the entire inheritance chain.\n    if (context.getDeclaration().heritageClauses.some(function (c) { return [\"PolymerElement\", \"Polymer.Element\"].includes(c.identifier.getText()); })) {\n        result = true;\n    }\n    context.cache.general.set(cacheKey, result);\n    return result;\n}\n/**\n * Returns an attribute name based on a property name and a lit-configuration\n * @param propName\n * @param litConfig\n * @param context\n */\nfunction getLitAttributeName(propName, litConfig, context) {\n    // Don't emit attribute if the value is specifically \"false\"\n    if (litConfig.attribute === false) {\n        return undefined;\n    }\n    // Get the attribute name either by looking at \"{attribute: ...}\" or just taking the property name.\n    var attrName = typeof litConfig.attribute === \"string\" ? litConfig.attribute : propName;\n    if (inPolymerFlavorContext(context)) {\n        // From the documentation: https://polymer-library.polymer-project.org/3.0/docs/devguide/properties#attribute-reflection\n        attrName = camelToDashCase(attrName).toLowerCase();\n    }\n    return attrName;\n}\n/**\n * Visits static properties\n * static get properties() { return { myProp: {type: String, attribute: \"my-attr\"} } }\n * @param returnStatement\n * @param context\n */\nfunction parseStaticProperties(returnStatement, context) {\n    var e_1, _a;\n    var ts = context.ts;\n    var memberResults = [];\n    if (returnStatement.expression != null && ts.isObjectLiteralExpression(returnStatement.expression)) {\n        var _loop_1 = function (propNode) {\n            // Get propName\n            var propName = propNode.name != null && ts.isIdentifier(propNode.name) ? propNode.name.text : undefined;\n            if (propName == null) {\n                return \"continue\";\n            }\n            // Parse the lit property config for this property\n            // Treat non-object-literal-expressions like the \"type\" (to support Polymer specific syntax)\n            var litConfig = ts.isPropertyAssignment(propNode)\n                ? ts.isObjectLiteralExpression(propNode.initializer)\n                    ? getLitPropertyOptions(propNode.initializer, context)\n                    : inPolymerFlavorContext(context)\n                        ? parseLitPropertyOption({\n                            kind: \"type\",\n                            initializer: propNode.initializer,\n                            config: {}\n                        }, context)\n                        : {}\n                : {};\n            // Get attrName based on the litConfig\n            var attrName = getLitAttributeName(propName, litConfig, context);\n            // Get more metadata\n            var jsDoc = getJsDoc(propNode, ts);\n            var emitAttribute = litConfig.attribute !== false;\n            // Emit either the attribute or the property\n            memberResults.push({\n                priority: \"high\",\n                kind: \"property\",\n                type: lazy(function () {\n                    return (jsDoc && getJsDocType(jsDoc)) || (typeof litConfig.type === \"object\" && litConfig.type) || { kind: ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].ANY };\n                }),\n                propName: propName,\n                attrName: emitAttribute ? attrName : undefined,\n                jsDoc: jsDoc,\n                node: propNode,\n                meta: litConfig,\n                default: litConfig.default,\n                reflect: litConfig.reflect ? \"both\" : attrName != null ? \"to-property\" : undefined\n            });\n        };\n        try {\n            // Each property in the object literal expression corresponds to a class field.\n            for (var _b = __values(returnStatement.expression.properties), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var propNode = _c.value;\n                _loop_1(propNode);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    }\n    return memberResults;\n}\n\nfunction excludeNode$1(node, context) {\n    if (context.config.analyzeDependencies) {\n        return undefined;\n    }\n    // Exclude lit element related super classes if \"analyzeLib\" is false\n    var declName = getNodeName(node, context);\n    if (declName != null) {\n        return declName === \"LitElement\" || declName === \"UpdatingElement\";\n    }\n    else {\n        var fileName = node.getSourceFile().fileName;\n        return fileName.includes(\"/lit-element.\") || fileName.endsWith(\"/updating-element.\");\n    }\n}\n\nvar refineFeature$1 = {\n    method: function (method, context) {\n        // This is temporary, but for now we force lit-element named methods to be protected\n        if (LIT_ELEMENT_PROTECTED_METHODS.includes(method.name)) {\n            return __assign(__assign({}, method), { visibility: \"protected\" });\n        }\n        return method;\n    }\n};\nvar LIT_ELEMENT_PROTECTED_METHODS = [\"render\", \"requestUpdate\", \"firstUpdated\", \"updated\", \"update\", \"shouldUpdate\"];\n\n/**\n * Flavors for analyzing LitElement related features: https://lit-element.polymer-project.org/\n */\nvar LitElementFlavor = /** @class */ (function () {\n    function LitElementFlavor() {\n        this.excludeNode = excludeNode$1;\n        this.discoverDefinitions = discoverDefinitions$3;\n        this.discoverFeatures = {\n            member: discoverMembers$1\n        };\n        this.refineFeature = refineFeature$1;\n    }\n    return LitElementFlavor;\n}());\n\nvar VERSION = \"1.0.3\";\nvar DEFAULT_FLAVORS = [new LitElementFlavor(), new CustomElementFlavor(), new JsDocFlavor(), new JSXFlavor()];\nvar DEFAULT_FEATURE_COLLECTION_CACHE = new WeakMap();\nvar DEFAULT_COMPONENT_DECLARATION_CACHE = new WeakMap();\n\nvar ALL_COMPONENT_FEATURES = [\"member\", \"method\", \"cssproperty\", \"csspart\", \"event\", \"slot\"];\n\n/**\n * Creates an \"analyzer visit context\" based on some options\n * @param options\n */\nfunction makeContextFromConfig(options) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    if (options.program == null) {\n        throw new Error(\"A program is required when running 'analyzeSourceFile'\");\n    }\n    // Assign defaults\n    var flavors = options.flavors || DEFAULT_FLAVORS;\n    var ts = options.ts || typescript__WEBPACK_IMPORTED_MODULE_0__;\n    var checker = options.program.getTypeChecker();\n    // Create context\n    return {\n        checker: checker,\n        ts: ts,\n        flavors: flavors,\n        cache: {\n            featureCollection: DEFAULT_FEATURE_COLLECTION_CACHE,\n            componentDeclaration: DEFAULT_COMPONENT_DECLARATION_CACHE,\n            general: new Map()\n        },\n        config: __assign(__assign({}, options.config), { analyzeDefaultLib: (_b = (_a = options.config) === null || _a === void 0 ? void 0 : _a.analyzeDefaultLib, (_b !== null && _b !== void 0 ? _b : false)), analyzeDependencies: (_d = (_c = options.config) === null || _c === void 0 ? void 0 : _c.analyzeDependencies, (_d !== null && _d !== void 0 ? _d : false)), excludedDeclarationNames: (_f = (_e = options.config) === null || _e === void 0 ? void 0 : _e.excludedDeclarationNames, (_f !== null && _f !== void 0 ? _f : [])), features: (_h = (_g = options.config) === null || _g === void 0 ? void 0 : _g.features, (_h !== null && _h !== void 0 ? _h : ALL_COMPONENT_FEATURES)) })\n    };\n}\n\n/**\n * Prepares a map of component features and a callback map that adds to the component feature map.\n */\nfunction prepareRefineEmitMap() {\n    var collection = {\n        members: [],\n        methods: [],\n        events: [],\n        slots: [],\n        cssProperties: [],\n        cssParts: []\n    };\n    var refineEmitMap = {\n        event: function (event) { return collection.events.push(event); },\n        member: function (member) { return collection.members.push(member); },\n        csspart: function (cssPart) { return collection.cssParts.push(cssPart); },\n        cssproperty: function (cssProperty) { return collection.cssProperties.push(cssProperty); },\n        method: function (method) { return collection.methods.push(method); },\n        slot: function (slot) { return collection.slots.push(slot); }\n    };\n    return {\n        collection: collection,\n        refineEmitMap: refineEmitMap\n    };\n}\n\n/**\n * Uses flavors to refine a feature\n * Flavors can also remove a feature\n * @param featureKind\n * @param value\n * @param context\n * @param emitMap\n */\nfunction refineFeature$2(featureKind, value, context, emitMap) {\n    /*if (Array.isArray(value)) {\n        value.forEach(v => refineComponentFeature(featureKind, v, context, emitMap));\n        return;\n    }*/\n    var e_1, _a, e_2, _b, e_3, _c;\n    var _d;\n    var refinedValue = value;\n    // Add \"declaration\" to the feature if necessary\n    if (\"getDeclaration\" in context && refinedValue != null) {\n        var decl = context.getDeclaration();\n        if (Array.isArray(refinedValue)) {\n            try {\n                for (var refinedValue_1 = __values(refinedValue), refinedValue_1_1 = refinedValue_1.next(); !refinedValue_1_1.done; refinedValue_1_1 = refinedValue_1.next()) {\n                    var val = refinedValue_1_1.value;\n                    if (val.declaration == null) {\n                        val.declaration = decl;\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (refinedValue_1_1 && !refinedValue_1_1.done && (_a = refinedValue_1.return)) _a.call(refinedValue_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        }\n        else if (refinedValue.declaration == null) {\n            refinedValue.declaration = decl;\n        }\n    }\n    try {\n        for (var _e = __values(context.flavors), _f = _e.next(); !_f.done; _f = _e.next()) {\n            var flavor = _f.value;\n            var refineFunc = (_d = flavor.refineFeature) === null || _d === void 0 ? void 0 : _d[featureKind];\n            if (refineFunc != null) {\n                if (refinedValue == null) {\n                    return;\n                }\n                else if (Array.isArray(refinedValue)) {\n                    var newValue = [];\n                    try {\n                        for (var refinedValue_2 = (e_3 = void 0, __values(refinedValue)), refinedValue_2_1 = refinedValue_2.next(); !refinedValue_2_1.done; refinedValue_2_1 = refinedValue_2.next()) {\n                            var val = refinedValue_2_1.value;\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            var refined = refineFunc(val, context);\n                            if (refined != null) {\n                                newValue.push.apply(newValue, __spread((Array.isArray(refined) ? refined : [refined])));\n                            }\n                        }\n                    }\n                    catch (e_3_1) { e_3 = { error: e_3_1 }; }\n                    finally {\n                        try {\n                            if (refinedValue_2_1 && !refinedValue_2_1.done && (_c = refinedValue_2.return)) _c.call(refinedValue_2);\n                        }\n                        finally { if (e_3) throw e_3.error; }\n                    }\n                    refinedValue = newValue.length === 0 ? undefined : newValue;\n                }\n                else {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    refinedValue = refineFunc(refinedValue, context);\n                }\n            }\n        }\n    }\n    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n    finally {\n        try {\n            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n        }\n        finally { if (e_2) throw e_2.error; }\n    }\n    if (refinedValue != null) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (Array.isArray(refinedValue) ? refinedValue : [refinedValue]).forEach(function (v) { var _a, _b, _c; return (_c = (_a = emitMap) === null || _a === void 0 ? void 0 : (_b = _a)[featureKind]) === null || _c === void 0 ? void 0 : _c.call(_b, v); });\n    }\n}\n\n/**\n * Uses flavors to find features for a node\n * @param node\n * @param context\n * @param emitMap\n */\nfunction visitFeatures(node, context, emitMap) {\n    var visitMaps = arrayDefined(context.flavors.map(function (flavor) { return flavor.discoverFeatures; }));\n    visitFeaturesWithVisitMaps(node, context, visitMaps, emitMap);\n}\n/**\n * Uses flavors to find features for a node, using a visit map\n * @param node\n * @param context\n * @param visitMaps\n * @param emitMap\n */\nfunction visitFeaturesWithVisitMaps(node, context, visitMaps, emitMap) {\n    var e_1, _a, e_2, _b;\n    var _c, _d, _e, _f;\n    try {\n        for (var _g = __values(context.config.features || []), _h = _g.next(); !_h.done; _h = _g.next()) {\n            var feature = _h.value;\n            try {\n                // Visit all features: always \"continue\"\n                for (var visitMaps_1 = (e_2 = void 0, __values(visitMaps)), visitMaps_1_1 = visitMaps_1.next(); !visitMaps_1_1.done; visitMaps_1_1 = visitMaps_1.next()) {\n                    var functionMap = visitMaps_1_1.value;\n                    var func = (_c = functionMap) === null || _c === void 0 ? void 0 : _c[feature];\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    var value = (_d = func) === null || _d === void 0 ? void 0 : _d(node, context);\n                    if (value != null) {\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        (_f = (_e = emitMap)[feature]) === null || _f === void 0 ? void 0 : _f.call(_e, value);\n                    }\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (visitMaps_1_1 && !visitMaps_1_1.done && (_b = visitMaps_1.return)) _b.call(visitMaps_1);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (_h && !_h.done && (_a = _g.return)) _a.call(_g);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    // Visit child nodes\n    node.forEachChild(function (child) {\n        visitFeaturesWithVisitMaps(child, context, visitMaps, emitMap);\n    });\n}\n\n/**\n * Merges two jsdocs\n * @param leftJsDoc\n * @param rightJsDoc\n */\nfunction mergeJsDoc(leftJsDoc, rightJsDoc) {\n    var _a;\n    if (leftJsDoc == null) {\n        return rightJsDoc;\n    }\n    else if (rightJsDoc == null) {\n        return leftJsDoc;\n    }\n    return __assign(__assign({}, ((leftJsDoc !== null && leftJsDoc !== void 0 ? leftJsDoc : rightJsDoc))), { description: (_a = leftJsDoc.description, (_a !== null && _a !== void 0 ? _a : rightJsDoc.description)) });\n}\n/**\n * Merges modifiers\n * @param leftModifiers\n * @param rightModifiers\n */\nfunction mergeModifiers(leftModifiers, rightModifiers) {\n    var _a, _b, _c, _d;\n    var newSet = new Set();\n    if (((_a = leftModifiers) === null || _a === void 0 ? void 0 : _a.has(\"static\")) && ((_b = rightModifiers) === null || _b === void 0 ? void 0 : _b.has(\"static\"))) {\n        newSet.add(\"static\");\n    }\n    if (((_c = leftModifiers) === null || _c === void 0 ? void 0 : _c.has(\"readonly\")) && ((_d = rightModifiers) === null || _d === void 0 ? void 0 : _d.has(\"readonly\"))) {\n        newSet.add(\"readonly\");\n    }\n    if (newSet.size === 0) {\n        return undefined;\n    }\n    return newSet;\n}\n/**\n * Merges based on a name\n * @param entries\n * @param direction\n * @param getName\n * @param merge\n */\nfunction mergeNamedEntries(entries, getName, merge) {\n    var e_1, _a;\n    var merged = new Map();\n    try {\n        for (var entries_1 = __values(entries), entries_1_1 = entries_1.next(); !entries_1_1.done; entries_1_1 = entries_1.next()) {\n            var entry = entries_1_1.value;\n            var name_1 = getName(entry);\n            var existing = merged.get(name_1);\n            if (existing == null) {\n                merged.set(name_1, entry);\n            }\n            else if (merge != null) {\n                merged.set(name_1, merge(existing, entry));\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (entries_1_1 && !entries_1_1.done && (_a = entries_1.return)) _a.call(entries_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return Array.from(merged.values());\n}\n\n/**\n * Merges multiple slots\n * @param slots\n */\nfunction mergeSlots(slots) {\n    return mergeNamedEntries(slots, function (slot) { return slot.name || \"\"; });\n}\n/**\n * Merges multiple css parts\n * @param cssParts\n */\nfunction mergeCssParts(cssParts) {\n    return mergeNamedEntries(cssParts, function (cssPart) { return cssPart.name; });\n}\n/**\n * Merges multiple css properties\n * @param cssProps\n */\nfunction mergeCssProperties(cssProps) {\n    return mergeNamedEntries(cssProps, function (cssProp) { return cssProp.name; });\n}\n/**\n * Merges multiple methods\n * @param methods\n */\nfunction mergeMethods(methods) {\n    return mergeNamedEntries(methods, function (method) { return method.name; }, function (left, right) { return (__assign(__assign({}, left), { jsDoc: mergeJsDoc(left.jsDoc, right.jsDoc) })); });\n    /*return mergeEntries(\n        methods,\n        (method, mergedMethod) => {\n            if (method.name === mergedMethod.name) {\n                return (method.modifiers?.has(\"static\") || false) === (mergedMethod.modifiers?.has(\"static\") || false);\n            }\n\n            return false;\n        },\n        (left, right) => ({\n            ...left,\n            jsDoc: mergeJsDoc(left.jsDoc, right.jsDoc),\n            modifiers: mergeModifiers(left.modifiers, right.modifiers)\n        })\n    );*/\n}\n/**\n * Merges multiple events\n * @param events\n */\nfunction mergeEvents(events) {\n    return mergeNamedEntries(events, function (event) { return event.name; }, function (left, right) { return (__assign(__assign({}, left), { jsDoc: mergeJsDoc(left.jsDoc, right.jsDoc) })); });\n}\n\nvar priorityValueMap = {\n    low: 0,\n    medium: 1,\n    high: 2\n};\n/**\n * Merges multiple members based on priority\n * @param members\n * @param context\n */\nfunction mergeMembers(members, context) {\n    var e_1, _a;\n    // Start merging by sorting member results from high to low priority.\n    // If two priorities are the same: prioritize the first found element\n    // From node 11, equal elements keep their order after sort, but not in node 10\n    // Therefore we use \"indexOf\" to return correct order if two priorities are equal\n    members = __spread(members).sort(function (a, b) {\n        var vA = priorityValueMap[a.priority];\n        var vB = priorityValueMap[b.priority];\n        if (vA === vB) {\n            var iA = members.indexOf(a);\n            var iB = members.indexOf(b);\n            return iA < iB ? -1 : 1;\n        }\n        return vA < vB ? 1 : -1;\n    });\n    // Keep track of merged props and merged attributes\n    // These are stored in maps for speed, because we are going to lookup a member per each memberResult\n    var mergeMap = {\n        props: new Map(),\n        attrs: new Map()\n    };\n    try {\n        // Merge all members one by one adding them to the merge map\n        for (var members_1 = __values(members), members_1_1 = members_1.next(); !members_1_1.done; members_1_1 = members_1.next()) {\n            var member = members_1_1.value;\n            // Find a member that is similar to this member\n            var mergeableMember = findMemberToMerge(member, mergeMap);\n            var newMember = undefined;\n            if (mergeableMember == null) {\n                // No mergeable member was found, so just add this to the map\n                newMember = member;\n            }\n            else {\n                // Remove \"member\" and \"mergeableMember\" from the merge map\n                // We are going to merge those and add the result to the merge map again\n                clearMergeMapWithMember(mergeableMember, mergeMap);\n                clearMergeMapWithMember(member, mergeMap);\n                newMember = mergeMemberIntoMember(mergeableMember, member, context.checker);\n            }\n            // Add to merge map\n            switch (newMember.kind) {\n                case \"attribute\":\n                    mergeMap.attrs.set(newMember.attrName, newMember);\n                    break;\n                case \"property\":\n                    mergeMap.props.set(newMember.propName, newMember);\n                    break;\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (members_1_1 && !members_1_1.done && (_a = members_1.return)) _a.call(members_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    // Return merged results with only \"high\" priorities\n    return __spread(mergeMap.props.values(), mergeMap.attrs.values()).map(function (member) { return (__assign(__assign({}, member), { priority: \"high\" })); });\n}\n/**\n * Removes a member from the merge map\n * @param member\n * @param mergeMap\n */\nfunction clearMergeMapWithMember(member, mergeMap) {\n    switch (member.kind) {\n        case \"attribute\":\n            mergeMap.attrs.delete(member.attrName);\n            break;\n        case \"property\":\n            mergeMap.props.delete(member.propName);\n            if (member.attrName != null) {\n                mergeMap.attrs.delete(member.attrName);\n            }\n            break;\n    }\n}\n/**\n * Finds a mergeable member\n * @param similar\n * @param mergeMap\n */\nfunction findMemberToMerge(similar, mergeMap) {\n    var e_2, _a;\n    var attrName = similar.attrName; //?.toLowerCase(); // (similar.kind === \"attribute\" && similar.attrName.toLowerCase()) || undefined;\n    var propName = similar.propName; /*?.toLowerCase()*/ //(similar.kind === \"property\" && similar.propName.toLowerCase()) || undefined;\n    // Return a member that matches either propName (prioritized) or attrName\n    if (propName != null) {\n        var mergeable = mergeMap.props.get(propName) || mergeMap.attrs.get(propName);\n        if (mergeable != null) {\n            return mergeable;\n        }\n    }\n    if (attrName != null) {\n        var mergeableAttr = mergeMap.attrs.get(attrName);\n        if (mergeableAttr != null) {\n            return mergeableAttr;\n        }\n        // Try to find a prop with the attr name.\n        // Don't return the prop if it already has an attribute that is not equals to the attr name\n        var mergeableProp = mergeMap.props.get(attrName);\n        if (mergeableProp != null && mergeableProp.attrName == null) {\n            return mergeableProp;\n        }\n        try {\n            for (var _b = __values(mergeMap.props.values()), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var mergedAttr = _c.value;\n                if (mergedAttr.attrName === attrName) {\n                    return mergedAttr;\n                }\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n    }\n}\n/**\n * Merges two members of the same kind into each other.\n * This operation prioritizes leftMember\n * @param leftMember\n * @param rightMember\n * @param checker\n */\nfunction mergeMemberIntoMember(leftMember, rightMember, checker) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    // Always prioritize merging attribute into property if possible\n    if (leftMember.kind === \"attribute\" && rightMember.kind === \"property\") {\n        return mergeMemberIntoMember(rightMember, leftMember);\n    }\n    return __assign(__assign({}, leftMember), { attrName: (_a = leftMember.attrName, (_a !== null && _a !== void 0 ? _a : rightMember.attrName)), type: (function () {\n            var _a, _b;\n            // Always prioritize a \"property\" over an \"attribute\" when merging types\n            if (leftMember.kind === rightMember.kind || leftMember.kind === \"property\") {\n                return _a = leftMember.type, (_a !== null && _a !== void 0 ? _a : rightMember.type);\n            }\n            else if (rightMember.kind === \"property\") {\n                return _b = rightMember.type, (_b !== null && _b !== void 0 ? _b : leftMember.type);\n            }\n        })(), typeHint: (_b = leftMember.typeHint, (_b !== null && _b !== void 0 ? _b : rightMember.typeHint)), jsDoc: mergeJsDoc(leftMember.jsDoc, rightMember.jsDoc), modifiers: mergeModifiers(leftMember.modifiers, rightMember.modifiers), meta: (_c = leftMember.meta, (_c !== null && _c !== void 0 ? _c : rightMember.meta)), default: leftMember.default === undefined ? rightMember.default : leftMember.default, required: (_d = leftMember.required, (_d !== null && _d !== void 0 ? _d : rightMember.required)), visibility: (_e = leftMember.visibility, (_e !== null && _e !== void 0 ? _e : rightMember.visibility)), deprecated: (_f = leftMember.deprecated, (_f !== null && _f !== void 0 ? _f : rightMember.deprecated)), declaration: (_g = rightMember.declaration, (_g !== null && _g !== void 0 ? _g : leftMember.declaration)) });\n}\n\n/**\n * Merges all features in collections of features\n * @param collection\n * @param context\n */\nfunction mergeFeatures(collection, context) {\n    if (Array.isArray(collection)) {\n        if (collection.length === 1) {\n            return collection[0];\n        }\n        collection = {\n            cssParts: arrayFlat(collection.map(function (c) { return c.cssParts; })),\n            cssProperties: arrayFlat(collection.map(function (c) { return c.cssProperties; })),\n            events: arrayFlat(collection.map(function (c) { return c.events; })),\n            members: arrayFlat(collection.map(function (c) { return c.members; })),\n            methods: arrayFlat(collection.map(function (c) { return c.methods; })),\n            slots: arrayFlat(collection.map(function (c) { return c.slots; }))\n        };\n        return mergeFeatures(collection, context);\n    }\n    return {\n        cssParts: mergeCssParts(collection.cssParts),\n        cssProperties: mergeCssProperties(collection.cssProperties),\n        events: mergeEvents(collection.events),\n        members: mergeMembers(collection.members, context),\n        methods: mergeMethods(collection.methods),\n        slots: mergeSlots(collection.slots)\n    };\n}\n\n/**\n * Discovers features for a given node using flavors\n * @param node\n * @param context\n */\nfunction discoverFeatures$1(node, context) {\n    // Return the result if we already found this node\n    if (context.cache.featureCollection.has(node)) {\n        return context.cache.featureCollection.get(node);\n    }\n    var _a = prepareRefineEmitMap(), collection = _a.collection, refineEmitMap = _a.refineEmitMap;\n    // Discovers features for \"node\" using flavors\n    visitFeatures(node, context, {\n        event: function (event) { return refineFeature$2(\"event\", event, context, refineEmitMap); },\n        member: function (memberResult) { return refineFeature$2(\"member\", memberResult, context, refineEmitMap); },\n        csspart: function (cssPart) { return refineFeature$2(\"csspart\", cssPart, context, refineEmitMap); },\n        cssproperty: function (cssProperty) { return refineFeature$2(\"cssproperty\", cssProperty, context, refineEmitMap); },\n        method: function (method) { return refineFeature$2(\"method\", method, context, refineEmitMap); },\n        slot: function (slot) { return refineFeature$2(\"slot\", slot, context, refineEmitMap); }\n    });\n    // Merge features that were found\n    var mergedCollection = mergeFeatures(collection, context);\n    // Cache the features for this node\n    context.cache.featureCollection.set(node, mergedCollection);\n    return mergedCollection;\n}\n\n/**\n * Uses flavors to find inheritance for a node\n * @param node\n * @param context\n * @param emit\n * @param visitSet\n */\nfunction visitInheritance(node, context, emit, visitSet) {\n    var e_1, _a;\n    var _b, _c;\n    try {\n        for (var _d = __values(context.flavors), _e = _d.next(); !_e.done; _e = _d.next()) {\n            var flavor = _e.value;\n            var result = (_c = (_b = flavor).discoverInheritance) === null || _c === void 0 ? void 0 : _c.call(_b, node, context);\n            if (result != null) {\n                emit(result);\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n}\n\n/**\n * Uses flavors in order to discover inheritance from one of more nodes.\n * @param startNode\n * @param visitedNodes\n * @param context\n */\nfunction discoverInheritance$1(startNode, visitedNodes, context) {\n    var e_1, _a;\n    var nodes = Array.isArray(startNode) ? startNode : [startNode];\n    var declarationKind = undefined;\n    var heritageClauses = [];\n    var declarationNodes = new Set();\n    try {\n        for (var nodes_1 = __values(nodes), nodes_1_1 = nodes_1.next(); !nodes_1_1.done; nodes_1_1 = nodes_1.next()) {\n            var node = nodes_1_1.value;\n            visitedNodes.add(node);\n            // Visit inheritance using flavors\n            visitInheritance(node, context, function (result) {\n                var e_2, _a;\n                // Combine results into one single result\n                declarationKind = declarationKind || result.declarationKind;\n                if (result.declarationNodes != null) {\n                    try {\n                        for (var _b = (e_2 = void 0, __values(result.declarationNodes)), _c = _b.next(); !_c.done; _c = _b.next()) {\n                            var node_1 = _c.value;\n                            declarationNodes.add(node_1);\n                        }\n                    }\n                    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                    finally {\n                        try {\n                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                        }\n                        finally { if (e_2) throw e_2.error; }\n                    }\n                }\n                if (result.heritageClauses != null) {\n                    heritageClauses.push.apply(heritageClauses, __spread(result.heritageClauses));\n                }\n            });\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (nodes_1_1 && !nodes_1_1.done && (_a = nodes_1.return)) _a.call(nodes_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return {\n        declarationNodes: Array.from(declarationNodes),\n        heritageClauses: heritageClauses,\n        declarationKind: declarationKind || \"class\"\n    };\n}\n\n/**\n * Uses flavors to determine if a node should be excluded from the output\n * @param node\n * @param context\n */\nfunction excludeNode$2(node, context) {\n    var e_1, _a;\n    var _b, _c;\n    try {\n        for (var _d = __values(context.flavors), _e = _d.next(); !_e.done; _e = _d.next()) {\n            var flavor = _e.value;\n            var exclude = (_c = (_b = flavor).excludeNode) === null || _c === void 0 ? void 0 : _c.call(_b, node, context);\n            if (exclude) {\n                return true;\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return false;\n}\n\n/**\n * Uses flavors to refine a declaration\n * @param declaration\n * @param context\n */\nfunction refineDeclaration$1(declaration, context) {\n    var e_1, _a;\n    var _b, _c, _d;\n    try {\n        for (var _e = __values(context.flavors), _f = _e.next(); !_f.done; _f = _e.next()) {\n            var flavor = _f.value;\n            declaration = (_d = (_c = (_b = flavor).refineDeclaration) === null || _c === void 0 ? void 0 : _c.call(_b, declaration, context), (_d !== null && _d !== void 0 ? _d : declaration));\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (_f && !_f.done && (_a = _e.return)) _a.call(_e);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return declaration;\n}\n\n/**\n * Discovers features on component declaration nodes\n * @param initialDeclarationNodes\n * @param baseContext\n * @param options\n */\nfunction analyzeComponentDeclaration(initialDeclarationNodes, baseContext, options) {\n    var e_1, _a, e_2, _b, e_3, _c;\n    if (options === void 0) { options = {}; }\n    var mainDeclarationNode = initialDeclarationNodes[0];\n    if (mainDeclarationNode == null) {\n        throw new Error(\"Couldn't find main declaration node\");\n    }\n    // Return right away from the cache if any\n    // TODO: better handle invalidating this cache.\n    if (baseContext.cache.componentDeclaration.has(mainDeclarationNode)) {\n        return baseContext.cache.componentDeclaration.get(mainDeclarationNode);\n    }\n    options.visitedNodes = options.visitedNodes || new Set();\n    // Discover inheritance\n    var _d = discoverInheritance$1(initialDeclarationNodes, options.visitedNodes, baseContext), declarationKind = _d.declarationKind, declarationNodes = _d.declarationNodes, heritageClauses = _d.heritageClauses;\n    try {\n        // Expand all heritage clauses with the component declaration\n        for (var heritageClauses_1 = __values(heritageClauses), heritageClauses_1_1 = heritageClauses_1.next(); !heritageClauses_1_1.done; heritageClauses_1_1 = heritageClauses_1.next()) {\n            var heritageClause = heritageClauses_1_1.value;\n            // Only resolve declarations we haven't yet seen and shouldn't be excluded\n            var declarations = resolveDeclarations(heritageClause.identifier, baseContext).filter(function (n) { var _a; return !((_a = options.visitedNodes) === null || _a === void 0 ? void 0 : _a.has(n)) && !shouldExcludeNode(n, baseContext); });\n            if (declarations.length > 0) {\n                heritageClause.declaration = analyzeComponentDeclaration(declarations, baseContext, options);\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (heritageClauses_1_1 && !heritageClauses_1_1.done && (_a = heritageClauses_1.return)) _a.call(heritageClauses_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    // Get symbol of main declaration node\n    var symbol = getSymbol(mainDeclarationNode, baseContext);\n    var baseDeclaration = {\n        node: mainDeclarationNode,\n        declarationNodes: new Set(declarationNodes),\n        symbol: symbol,\n        heritageClauses: heritageClauses,\n        kind: declarationKind || \"class\",\n        events: [],\n        cssParts: [],\n        cssProperties: [],\n        members: [],\n        methods: [],\n        slots: [],\n        jsDoc: getJsDoc(mainDeclarationNode, baseContext.ts)\n    };\n    // Add the \"get declaration\" hook to the context\n    var context = __assign(__assign({}, baseContext), { declarationNode: mainDeclarationNode, getDeclaration: function () { return baseDeclaration; }, sourceFile: mainDeclarationNode.getSourceFile() });\n    // Find features on all declaration nodes\n    var featureCollections = [];\n    try {\n        for (var declarationNodes_1 = __values(declarationNodes), declarationNodes_1_1 = declarationNodes_1.next(); !declarationNodes_1_1.done; declarationNodes_1_1 = declarationNodes_1.next()) {\n            var node = declarationNodes_1_1.value;\n            if (shouldExcludeNode(node, context)) {\n                continue;\n            }\n            // Discover component features using flavors\n            featureCollections.push(discoverFeatures$1(node, __assign(__assign({}, context), { declarationNode: node })));\n        }\n    }\n    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n    finally {\n        try {\n            if (declarationNodes_1_1 && !declarationNodes_1_1.done && (_b = declarationNodes_1.return)) _b.call(declarationNodes_1);\n        }\n        finally { if (e_2) throw e_2.error; }\n    }\n    try {\n        // Add all inherited features to the feature collections array\n        for (var heritageClauses_2 = __values(heritageClauses), heritageClauses_2_1 = heritageClauses_2.next(); !heritageClauses_2_1.done; heritageClauses_2_1 = heritageClauses_2.next()) {\n            var heritageClause = heritageClauses_2_1.value;\n            if (heritageClause.declaration != null) {\n                featureCollections.push(__assign(__assign({}, heritageClause.declaration), { members: heritageClause.declaration.members }));\n            }\n        }\n    }\n    catch (e_3_1) { e_3 = { error: e_3_1 }; }\n    finally {\n        try {\n            if (heritageClauses_2_1 && !heritageClauses_2_1.done && (_c = heritageClauses_2.return)) _c.call(heritageClauses_2);\n        }\n        finally { if (e_3) throw e_3.error; }\n    }\n    // If all nodes were excluded, return empty declaration\n    if (featureCollections.length === 0) {\n        return baseDeclaration;\n    }\n    // Merge all features into one single collection prioritizing features found in first\n    var mergedFeatureCollection = mergeFeatures(featureCollections, context);\n    // Refine the declaration and return the result\n    var refinedDeclaration = refineDeclaration$1(__assign(__assign({}, baseDeclaration), { cssParts: mergedFeatureCollection.cssParts, cssProperties: mergedFeatureCollection.cssProperties, events: mergedFeatureCollection.events, methods: mergedFeatureCollection.methods, members: mergedFeatureCollection.members, slots: mergedFeatureCollection.slots }), context);\n    Object.assign(baseDeclaration, refinedDeclaration);\n    baseContext.cache.componentDeclaration.set(mainDeclarationNode, baseDeclaration);\n    return baseDeclaration;\n}\n/**\n * Returns if a node should be excluded from the analyzing\n * @param node\n * @param context\n */\nfunction shouldExcludeNode(node, context) {\n    var _a;\n    // Uses flavors to determine if the node should be excluded\n    if (excludeNode$2(node, context)) {\n        return true;\n    }\n    // It's possible to exclude declaration names\n    var name = getNodeName(node, context);\n    if (name != null && ((_a = context.config.excludedDeclarationNames) === null || _a === void 0 ? void 0 : _a.includes(name))) {\n        return true;\n    }\n    return false;\n}\n\n/**\n * Visits the source file and finds all component definitions using flavors\n * @param sourceFile\n * @param context\n */\nfunction discoverDeclarations(sourceFile, context) {\n    var e_1, _a;\n    var declarations = [];\n    var symbol = context.checker.getSymbolAtLocation(sourceFile);\n    if (symbol != null) {\n        // Get all exports in the source file\n        var exports_2 = context.checker.getExportsOfModule(symbol);\n        try {\n            // Find all class declarations in the source file\n            for (var exports_1 = __values(exports_2), exports_1_1 = exports_1.next(); !exports_1_1.done; exports_1_1 = exports_1.next()) {\n                var symbol_1 = exports_1_1.value;\n                var node = symbol_1.valueDeclaration;\n                if (node != null) {\n                    if (context.ts.isClassDeclaration(node) /* || context.ts.isInterfaceDeclaration(node)*/) {\n                        var nodes = resolveSymbolDeclarations(symbol_1);\n                        var decl = analyzeComponentDeclaration(nodes, context);\n                        declarations.push(decl);\n                    }\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (exports_1_1 && !exports_1_1.done && (_a = exports_1.return)) _a.call(exports_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    }\n    return declarations;\n}\n\n/**\n * Executes functions in a function map until some function returns a non-undefined value.\n * @param functionMaps\n * @param keys\n * @param arg\n * @param context\n */\nfunction executeFunctionsUntilMatch(functionMaps, keys, arg, context) {\n    var e_1, _a, e_2, _b;\n    keys = Array.isArray(keys) ? keys : [keys];\n    try {\n        for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {\n            var key = keys_1_1.value;\n            var _loop_1 = function (functionMap) {\n                var func = functionMap[key];\n                if (func == null)\n                    return \"continue\";\n                // Save a \"continue\" flag if necessary\n                var shouldContinue = false;\n                var result = func(arg, __assign(__assign({}, context), { emitContinue: function () {\n                        shouldContinue = true;\n                    } }));\n                // Return a result if not undefined\n                if (result != null) {\n                    return { value: { value: result, shouldContinue: shouldContinue } };\n                }\n            };\n            try {\n                // Loop through each function\n                for (var functionMaps_1 = (e_2 = void 0, __values(functionMaps)), functionMaps_1_1 = functionMaps_1.next(); !functionMaps_1_1.done; functionMaps_1_1 = functionMaps_1.next()) {\n                    var functionMap = functionMaps_1_1.value;\n                    var state_1 = _loop_1(functionMap);\n                    if (typeof state_1 === \"object\")\n                        return state_1.value;\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (functionMaps_1_1 && !functionMaps_1_1.done && (_b = functionMaps_1.return)) _b.call(functionMaps_1);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return undefined;\n}\n\n/**\n * Uses flavors to visit definitions\n * @param node\n * @param context\n * @param emit\n */\nfunction visitDefinitions(node, context, emit) {\n    var result = executeFunctionsUntilMatch(context.flavors, \"discoverDefinitions\", node, context);\n    if (result != null) {\n        emit(result.value);\n        if (!result.shouldContinue)\n            return;\n    }\n    // Visit child nodes\n    node.forEachChild(function (child) {\n        visitDefinitions(child, context, emit);\n    });\n}\n\n/**\n * Visits the source file and finds all component definitions using flavors\n * @param sourceFile\n * @param context\n * @param analyzeDeclaration\n */\nfunction discoverDefinitions$4(sourceFile, context, analyzeDeclaration) {\n    // Find all definitions in the file using flavors\n    var definitionResults = analyzeAndDedupeDefinitions(sourceFile, context);\n    return Array.from(definitionResults.entries()).map(function (_a) {\n        var _b = __read(_a, 2), definition = _b[0], declarationSet = _b[1];\n        return __assign(__assign({}, definition), { declaration: lazy(function () { return analyzeDeclaration(definition, Array.from(declarationSet)); }) });\n    });\n}\n/**\n * Finds all component definitions in a file and combine multiple declarations with same tag name.\n * @param node\n * @param context\n */\nfunction analyzeAndDedupeDefinitions(node, context) {\n    var e_1, _a, e_2, _b;\n    if (node == null)\n        return new Map();\n    // Keep a map of \"tag name\" ==> \"definition\"\n    var tagNameDefinitionMap = new Map();\n    // Keep a map of \"definition\" ==> \"declaration nodes\"\n    var definitionToDeclarationMap = new Map();\n    // Discover definitions using flavors\n    visitDefinitions(node, context, function (results) {\n        var e_3, _a, e_4, _b;\n        try {\n            // Definitions are unique by tag name and are merged when pointing to multiple declaration nodes.\n            // This is because multiple definitions can exist side by side for the same tag name (think global TagName type definition and customElements.define)\n            for (var results_3 = __values(results), results_3_1 = results_3.next(); !results_3_1.done; results_3_1 = results_3.next()) {\n                var result = results_3_1.value;\n                // Find existing definition with the result name\n                var definition = tagNameDefinitionMap.get(result.tagName);\n                if (definition == null) {\n                    // No existing definition was found, - create one!\n                    definition = {\n                        declaration: function () {\n                            throw new Error(\"This is a noop function. It's expected that this function is overwritten.\");\n                        },\n                        tagName: result.tagName,\n                        tagNameNodes: new Set(),\n                        identifierNodes: new Set()\n                    };\n                    tagNameDefinitionMap.set(result.tagName, definition);\n                }\n                // Add the discovered identifier node to the definition\n                if (result.identifierNode != null) {\n                    definition.identifierNodes.add(result.identifierNode);\n                }\n                // Add the discovered tag name node to the definition\n                if (result.tagNameNode) {\n                    definition.tagNameNodes.add(result.tagNameNode);\n                }\n                // Add the discovered declaration node to the map from \"definition\" ==> \"declaration nodes\"\n                var declarationNodeSet = definitionToDeclarationMap.get(definition);\n                if (declarationNodeSet == null) {\n                    declarationNodeSet = new Set();\n                    definitionToDeclarationMap.set(definition, declarationNodeSet);\n                }\n                // Grab the symbol from the identifier node and get the declarations\n                // If the is no symbol on the result, use \"result.declarationNode\" instead\n                var symbol = result.identifierNode != null ? getSymbol(result.identifierNode, context) : undefined;\n                var declarations = symbol != null ? resolveSymbolDeclarations(symbol) : result.declarationNode != null ? [result.declarationNode] : [];\n                try {\n                    for (var declarations_1 = (e_4 = void 0, __values(declarations)), declarations_1_1 = declarations_1.next(); !declarations_1_1.done; declarations_1_1 = declarations_1.next()) {\n                        var decl = declarations_1_1.value;\n                        declarationNodeSet.add(decl);\n                    }\n                }\n                catch (e_4_1) { e_4 = { error: e_4_1 }; }\n                finally {\n                    try {\n                        if (declarations_1_1 && !declarations_1_1.done && (_b = declarations_1.return)) _b.call(declarations_1);\n                    }\n                    finally { if (e_4) throw e_4.error; }\n                }\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (results_3_1 && !results_3_1.done && (_a = results_3.return)) _a.call(results_3);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n    });\n    // Remove duplicates where \"tagName\" is equals to \"\" if the declaration node is not used in any other definition.\n    var results = Array.from(definitionToDeclarationMap.entries());\n    try {\n        for (var results_1 = __values(results), results_1_1 = results_1.next(); !results_1_1.done; results_1_1 = results_1.next()) {\n            var _c = __read(results_1_1.value, 2), definition = _c[0], declarations = _c[1];\n            if (definition.tagName === \"\") {\n                var _loop_1 = function (checkDefinition, checkDeclarations) {\n                    // Find duplicated based on overlapping declarations\n                    if (definition !== checkDefinition && Array.from(declarations).find(function (decl) { return checkDeclarations.has(decl) != null; })) {\n                        definitionToDeclarationMap.delete(definition);\n                        return \"break\";\n                    }\n                };\n                try {\n                    for (var results_2 = (e_2 = void 0, __values(results)), results_2_1 = results_2.next(); !results_2_1.done; results_2_1 = results_2.next()) {\n                        var _d = __read(results_2_1.value, 2), checkDefinition = _d[0], checkDeclarations = _d[1];\n                        var state_1 = _loop_1(checkDefinition, checkDeclarations);\n                        if (state_1 === \"break\")\n                            break;\n                    }\n                }\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                finally {\n                    try {\n                        if (results_2_1 && !results_2_1.done && (_b = results_2.return)) _b.call(results_2);\n                    }\n                    finally { if (e_2) throw e_2.error; }\n                }\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (results_1_1 && !results_1_1.done && (_a = results_1.return)) _a.call(results_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return definitionToDeclarationMap;\n}\n\n/**\n * Uses flavors to find global features\n * @param node\n * @param context\n * @param emitMap\n */\nfunction visitGlobalFeatures(node, context, emitMap) {\n    var visitMaps = arrayDefined(context.flavors.map(function (flavor) { return flavor.discoverGlobalFeatures; }));\n    visitFeaturesWithVisitMaps(node, context, visitMaps, emitMap);\n}\n\n/**\n * Discover all global features using flavors\n * @param node\n * @param context\n */\nfunction discoverGlobalFeatures$3(node, context) {\n    var _a = prepareRefineEmitMap(), collection = _a.collection, refineEmitMap = _a.refineEmitMap;\n    // Discovers global features using flavors\n    visitGlobalFeatures(node, context, {\n        event: function (event) { return refineFeature$2(\"event\", event, context, refineEmitMap); },\n        member: function (memberResult) { return refineFeature$2(\"member\", memberResult, context, refineEmitMap); },\n        csspart: function (cssPart) { return refineFeature$2(\"csspart\", cssPart, context, refineEmitMap); },\n        cssproperty: function (cssProperty) { return refineFeature$2(\"cssproperty\", cssProperty, context, refineEmitMap); },\n        method: function (method) { return refineFeature$2(\"method\", method, context, refineEmitMap); },\n        slot: function (slot) { return refineFeature$2(\"slot\", slot, context, refineEmitMap); }\n    });\n    // Merge features in the collection\n    return mergeFeatures(collection, context);\n}\n\n/**\n * Analyzes all components in a source file.\n * @param sourceFile\n * @param options\n */\nfunction analyzeSourceFile(sourceFile, options) {\n    // Create a new context\n    var context = makeContextFromConfig(options);\n    // Analyze all components\n    var componentDefinitions = discoverDefinitions$4(sourceFile, context, function (definition, declarationNodes) {\n        // The component declaration is analyzed lazily\n        return analyzeComponentDeclaration(declarationNodes, context);\n    });\n    // Analyze global features\n    var globalFeatures = undefined;\n    if (context.config.analyzeGlobalFeatures) {\n        globalFeatures = discoverGlobalFeatures$3(sourceFile, context);\n    }\n    // Analyze exported declarations\n    var declarations = undefined;\n    if (context.config.analyzeAllDeclarations) {\n        declarations = discoverDeclarations(sourceFile, context);\n    }\n    return {\n        sourceFile: sourceFile,\n        componentDefinitions: componentDefinitions,\n        globalFeatures: globalFeatures,\n        declarations: declarations\n    };\n}\n\n/**\n * Returns the superclass heritage clause\n * @param declaration\n */\nfunction getSuperclassHeritageClause(declaration) {\n    return (declaration.heritageClauses.find(function (clause) { var _a; return clause.kind === \"extends\" && ((_a = clause.declaration) === null || _a === void 0 ? void 0 : _a.kind) === \"class\"; }) ||\n        declaration.heritageClauses.find(function (clause) { return clause.kind === \"extends\" && clause.declaration == null; }));\n}\n/**\n * Returns mixin heritage clauses for the declaration\n * @param declaration\n */\nfunction getMixinHeritageClauses(declaration) {\n    return declaration.heritageClauses.filter(function (clause) { return clause.kind === \"mixin\"; });\n}\n/**\n * Returns all extends heritage clauses for the declaration\n * @param declaration\n */\nfunction getExtendsHeritageClauses(declaration) {\n    return declaration.heritageClauses.filter(function (clause) { return clause.kind === \"extends\"; });\n}\n/**\n * Returns mixin heritage clauses for the declaration and all inherited declarations\n * @param declaration\n */\nfunction getMixinHeritageClausesInChain(declaration) {\n    var clauses = [];\n    visitAllHeritageClauses(declaration, function (clause) {\n        if (clause.kind === \"mixin\") {\n            clauses.push(clause);\n        }\n    });\n    return clauses;\n}\n/**\n * Returns extends heritage clauses for the declaration and all inherited declarations\n * @param declaration\n */\nfunction getExtendsHeritageClausesInChain(declaration) {\n    var clauses = [];\n    visitAllHeritageClauses(declaration, function (clause) {\n        if (clause.kind === \"extends\") {\n            clauses.push(clause);\n        }\n    });\n    return clauses;\n}\n/**\n * A helper function that makes it possible to visit all heritage clauses in the inheritance chain.\n * @param declaration\n * @param emit\n */\nfunction visitAllHeritageClauses(declaration, emit) {\n    var e_1, _a;\n    try {\n        for (var _b = __values(declaration.heritageClauses), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var clause = _c.value;\n            emit(clause);\n            if (clause.declaration != null) {\n                visitAllHeritageClauses(clause.declaration, emit);\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n}\n\nfunction isTypescriptNode(value) {\n    return value instanceof Object && \"kind\" in value && \"flags\" in value;\n}\nfunction isTypescriptSourceFile(value) {\n    return value instanceof Object && \"kind\" in value && \"fileName\" in value;\n}\nfunction isTypescriptType(value) {\n    return value instanceof Object && \"flags\" in value && \"checker\" in value;\n}\nfunction isSimpleType(value) {\n    return value instanceof Object && \"kind\" in value && Object.values(ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"]).includes(value.kind);\n}\n/**\n * Returns a representation of the input that can be JSON stringified\n */\nfunction stripTypescriptValues(input, checker) {\n    var e_1, _a;\n    var _b, _c, _d, _e, _f;\n    if (input == null) {\n        return input;\n    }\n    else if (typeof input === \"function\") {\n        return stripTypescriptValues(input(), checker);\n    }\n    else if (isTypescriptSourceFile(input)) {\n        return \"{SOURCEFILE:\" + ((_b = input.fileName.match(\".*/(.+)\")) === null || _b === void 0 ? void 0 : _b[1]) + \"}\";\n    }\n    else if (isTypescriptNode(input)) {\n        var title = \"escapedText\" in input ? input.escapedText : undefined;\n        return \"{NODE:\" + ((_f = (_e = (_d = (_c = input).getSourceFile) === null || _d === void 0 ? void 0 : _d.call(_c)) === null || _e === void 0 ? void 0 : _e.fileName.match(\".*/(.+)\")) === null || _f === void 0 ? void 0 : _f[1]) + (title != null ? \":\" + title : \"\") + \":\" + input.pos + \"}\";\n    }\n    else if (isTypescriptType(input)) {\n        if (checker == null) {\n            return \"{TYPE}\";\n        }\n        return \"{TYPE:\" + checker.typeToString(input) + \"}\";\n    }\n    else if (isSimpleType(input)) {\n        return \"{SIMPLE_TYPE:\" + Object(ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"toTypeString\"])(input) + \"}\";\n    }\n    else if (Array.isArray(input)) {\n        return input.map(function (i) { return stripTypescriptValues(i, checker); });\n    }\n    else if (input instanceof Set) {\n        return stripTypescriptValues(Array.from(input), checker);\n    }\n    else if (input instanceof Map) {\n        return stripTypescriptValues(Array.from(input), checker);\n    }\n    else if (input instanceof Object) {\n        var obj = {};\n        try {\n            for (var _g = __values(Object.entries(input)), _h = _g.next(); !_h.done; _h = _g.next()) {\n                var _j = __read(_h.value, 2), key = _j[0], value = _j[1];\n                var strippedValue = stripTypescriptValues(value, checker);\n                if (strippedValue !== undefined && (!Array.isArray(strippedValue) || strippedValue.length > 0)) {\n                    obj[key] = strippedValue;\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_h && !_h.done && (_a = _g.return)) _a.call(_g);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return obj;\n    }\n    return input;\n}\n\n/**\n * Transforms results to json.\n * @param results\n * @param program\n * @param config\n */\nvar debugJsonTransformer = function (results, program, config) {\n    var definitions = arrayFlat(results.map(function (res) { return res.componentDefinitions; }));\n    return JSON.stringify(stripTypescriptValues(definitions, program.getTypeChecker()), null, 2);\n};\n\n/**\n * Returns a \"type hint\" from a type\n * The type hint is an easy to read representation of the type and is not made for being parsed.\n * @param type\n * @param checker\n * @param config\n */\nfunction getTypeHintFromType(type, checker, config) {\n    if (type == null)\n        return undefined;\n    if (typeof type === \"string\")\n        return type;\n    var typeHint;\n    if (config.inlineTypes) {\n        // Inline aliased types\n        if (Object(ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"isSimpleType\"])(type)) {\n            // Expand a possible alias\n            if (isUnionTypeAlias(type)) {\n                type = type.target;\n            }\n            typeHint = Object(ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"simpleTypeToString\"])(type);\n        }\n        else {\n            // Transform using Typescript natively, to avoid transforming all types to simple types (overhead).\n            // The \"InTypeAlias\" flag expands the type.\n            typeHint = checker.typeToString(type, undefined, typescript__WEBPACK_IMPORTED_MODULE_0__[\"TypeFormatFlags\"].InTypeAlias);\n        }\n    }\n    else {\n        // Transform types to string\n        typeHint = Object(ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"toTypeString\"])(type, checker);\n    }\n    // Replace \"anys\" and \"{}\" with more human friendly representations\n    if (typeHint === \"any\")\n        return undefined;\n    if (typeHint === \"any[]\")\n        return \"array\";\n    if (typeHint === \"{}\")\n        return \"object\";\n    return typeHint;\n}\n/**\n * Checks if a type is a type alias simple type\n * @param simpleType\n */\nfunction isUnionTypeAlias(simpleType) {\n    return simpleType.kind === ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].ALIAS && simpleType.target.kind === ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].UNION;\n}\n\nvar VISIBILITY_NUMBER_MAP = {\n    private: 1,\n    protected: 2,\n    public: 3\n};\n/**\n * Removes all items from an array with visibilities that are less visible than \"visibility\".\n * @param visibility\n * @param array\n */\nfunction filterVisibility(visibility, array) {\n    if (visibility === void 0) { visibility = \"public\"; }\n    var target = VISIBILITY_NUMBER_MAP[visibility];\n    return array.filter(function (item) { return VISIBILITY_NUMBER_MAP[item.visibility || \"public\"] >= target; });\n}\n\n/**\n * Returns the first element in the set\n * @param set\n */\nfunction getFirst(set) {\n    return set.values().next().value;\n}\n\n/**\n * Transforms results to json.\n * @param results\n * @param program\n * @param config\n */\nvar jsonTransformer = function (results, program, config) {\n    var checker = program.getTypeChecker();\n    // Get all definitions\n    var definitions = arrayFlat(results.map(function (res) { return res.componentDefinitions; }));\n    // Transform all definitions into \"tags\"\n    var tags = definitions.map(function (d) { return definitionToHtmlDataTag(d, checker, config); });\n    var htmlData = {\n        version: \"experimental\",\n        tags: tags\n    };\n    return JSON.stringify(htmlData, null, 2);\n};\nfunction definitionToHtmlDataTag(definition, checker, config) {\n    var _a;\n    var declaration = definition.declaration();\n    // Grab path to the definition file if possible\n    var node = getFirst(definition.tagNameNodes) || getFirst(definition.identifierNodes);\n    var fileName = (_a = node) === null || _a === void 0 ? void 0 : _a.getSourceFile().fileName;\n    var path = fileName != null && config.cwd != null ? \"./\" + Object(path__WEBPACK_IMPORTED_MODULE_2__[\"relative\"])(config.cwd, fileName) : undefined;\n    var attributes = arrayDefined(filterVisibility(config.visibility, declaration.members).map(function (d) { return componentMemberToHtmlDataAttribute(d, checker, config); }));\n    var properties = arrayDefined(filterVisibility(config.visibility, declaration.members).map(function (d) { return componentMemberToHtmlDataProperty(d, checker, config); }));\n    var events = arrayDefined(filterVisibility(config.visibility, declaration.events).map(function (e) { return componentEventToHtmlDataEvent(e); }));\n    var slots = arrayDefined(declaration.slots.map(function (e) { return componentSlotToHtmlDataSlot(e); }));\n    var cssProperties = arrayDefined(declaration.cssProperties.map(function (p) { return componentCssPropToHtmlCssProp(p); }));\n    var cssParts = arrayDefined(declaration.cssParts.map(function (p) { return componentCssPartToHtmlCssPart(p); }));\n    return {\n        name: definition.tagName,\n        path: path,\n        description: getDescriptionFromJsDoc(declaration.jsDoc),\n        attributes: attributes.length === 0 ? undefined : attributes,\n        properties: properties.length === 0 ? undefined : properties,\n        events: events.length === 0 ? undefined : events,\n        slots: slots.length === 0 ? undefined : slots,\n        cssProperties: cssProperties.length === 0 ? undefined : cssProperties,\n        cssParts: cssParts.length === 0 ? undefined : cssParts,\n        deprecated: declaration.deprecated === true || typeof declaration.deprecated === \"string\" || undefined,\n        deprecatedMessage: typeof declaration.deprecated === \"string\" ? declaration.deprecated : undefined\n    };\n}\nfunction componentCssPropToHtmlCssProp(prop, checker) {\n    return {\n        name: prop.name || \"\",\n        description: getDescriptionFromJsDoc(prop.jsDoc),\n        type: prop.typeHint,\n        default: prop.default != null ? JSON.stringify(prop.default) : undefined\n    };\n}\nfunction componentCssPartToHtmlCssPart(part, checker) {\n    return {\n        name: part.name || \"\",\n        description: getDescriptionFromJsDoc(part.jsDoc)\n    };\n}\nfunction componentSlotToHtmlDataSlot(slot, checker) {\n    return {\n        name: slot.name || \"\",\n        description: getDescriptionFromJsDoc(slot.jsDoc)\n    };\n}\nfunction componentEventToHtmlDataEvent(event, checker) {\n    return {\n        name: event.name,\n        description: getDescriptionFromJsDoc(event.jsDoc),\n        deprecated: event.deprecated === true || undefined,\n        deprecatedMessage: typeof event.deprecated === \"string\" ? event.deprecated : undefined\n    };\n}\nfunction componentMemberToHtmlDataAttribute(member, checker, config) {\n    var _a, _b, _c;\n    if (member.attrName == null) {\n        return undefined;\n    }\n    return {\n        name: member.attrName,\n        description: getDescriptionFromJsDoc(member.jsDoc),\n        type: getTypeHintFromType((_a = member.typeHint, (_a !== null && _a !== void 0 ? _a : (_c = (_b = member).type) === null || _c === void 0 ? void 0 : _c.call(_b))), checker, config),\n        default: member.default != null ? JSON.stringify(member.default) : undefined,\n        deprecated: member.deprecated === true || undefined,\n        deprecatedMessage: typeof member.deprecated === \"string\" ? member.deprecated : undefined\n    };\n}\nfunction componentMemberToHtmlDataProperty(member, checker, config) {\n    var _a, _b, _c;\n    if (member.propName == null) {\n        return undefined;\n    }\n    return {\n        name: member.propName,\n        attribute: member.attrName,\n        description: getDescriptionFromJsDoc(member.jsDoc),\n        type: getTypeHintFromType((_a = member.typeHint, (_a !== null && _a !== void 0 ? _a : (_c = (_b = member).type) === null || _c === void 0 ? void 0 : _c.call(_b))), checker, config),\n        default: member.default != null ? JSON.stringify(member.default) : undefined,\n        deprecated: member.deprecated === true || undefined,\n        deprecatedMessage: typeof member.deprecated === \"string\" ? member.deprecated : undefined\n    };\n}\nfunction getDescriptionFromJsDoc(jsDoc) {\n    var _a;\n    return (_a = jsDoc) === null || _a === void 0 ? void 0 : _a.description;\n}\n\n/**\n * This method returns a \"type hint\" that represents the method signature\n * The resulting type takes jsdoc into account.\n * I couldn't find a way for Typescript to return the signature string taking jsdoc into account\n *   so therefore I had to do some regex-magic in this method.\n */\nfunction getTypeHintFromMethod(method, checker) {\n    var e_1, _a;\n    var _b, _c, _d, _e, _f, _g, _h, _j;\n    var signature = getTypeHintFromType((_c = (_b = method).type) === null || _c === void 0 ? void 0 : _c.call(_b), checker, {}) || \"\";\n    // Replace \"=>\" with \":\" and the return type with the returnTypeHint if present\n    signature = signature.replace(/\\)\\s*=>\\s?(.*)$/, \"): \" + (_g = (_f = (_e = (_d = method.jsDoc) === null || _d === void 0 ? void 0 : _d.tags) === null || _e === void 0 ? void 0 : _e.find(function (tag) { return [\"returns\", \"return\"].includes(tag.tag); })) === null || _f === void 0 ? void 0 : _f.parsed().type, (_g !== null && _g !== void 0 ? _g : \"$1\")));\n    try {\n        // Replace all \"any\" types with corresponding type hints\n        for (var _k = __values(((_j = (_h = method.jsDoc) === null || _h === void 0 ? void 0 : _h.tags) === null || _j === void 0 ? void 0 : _j.filter(function (tag) { return tag.tag === \"param\"; })) || []), _l = _k.next(); !_l.done; _l = _k.next()) {\n            var parameterJsDocTag = _l.value;\n            var parsed = parameterJsDocTag.parsed();\n            if (parsed.type != null) {\n                signature = signature.replace(new RegExp(parsed.name + \"(.*?:\\\\s*)any\\\\[?]?\"), parsed.name + \"$1\" + parsed.type);\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (_l && !_l.done && (_a = _k.return)) _a.call(_k);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    // Replace \"{}\" with more pleasant string\n    signature = signature.replace(\"{}\", \"object\");\n    return signature;\n}\n\n/**\n * Transforms results to json using the schema found in the PR at https://github.com/webcomponents/custom-elements-json/pull/9\n * @param results\n * @param program\n * @param config\n */\nvar json2Transformer = function (results, program, config) {\n    var context = {\n        config: config,\n        checker: program.getTypeChecker(),\n        program: program,\n        ts: typescript__WEBPACK_IMPORTED_MODULE_0__\n    };\n    // Flatten analyzer results expanding inherited declarations into the declaration array.\n    var flattenedAnalyzerResults = flattenAnalyzerResults(results);\n    // Transform all analyzer results into modules\n    var modules = flattenedAnalyzerResults.map(function (result) { return analyzerResultToModuleDoc(result, context); });\n    var htmlData = {\n        version: \"experimental\",\n        modules: modules\n    };\n    return JSON.stringify(htmlData, null, 2);\n};\n/**\n * Transforms an analyzer result into a module doc\n * @param result\n * @param context\n */\nfunction analyzerResultToModuleDoc(result, context) {\n    // Get all export docs from the analyzer result\n    var exports = getExportsDocsFromAnalyzerResult(result, context);\n    return {\n        path: getRelativePath(result.sourceFile.fileName, context),\n        exports: exports.length === 0 ? undefined : exports\n    };\n}\n/**\n * Returns ExportDocs in an analyzer result\n * @param result\n * @param context\n */\nfunction getExportsDocsFromAnalyzerResult(result, context) {\n    // Return all class- and variable-docs\n    return __spread(getClassDocsFromAnalyzerResult(result, context), getVariableDocsFromAnalyzerResult(result, context), getFunctionDocsFromAnalyzerResult());\n}\n/**\n * Returns FunctionDocs in an analyzer result\n * @param result\n * @param context\n */\nfunction getFunctionDocsFromAnalyzerResult(result, context) {\n    // TODO: support function exports\n    return [];\n}\n/**\n * Returns VariableDocs in an analyzer result\n * @param result\n * @param context\n */\nfunction getVariableDocsFromAnalyzerResult(result, context) {\n    var e_1, _a;\n    var _b;\n    var varDocs = [];\n    // Get all export symbols in the source file\n    var symbol = context.checker.getSymbolAtLocation(result.sourceFile);\n    if (symbol == null) {\n        return [];\n    }\n    var exports = context.checker.getExportsOfModule(symbol);\n    try {\n        // Convert all export variables to VariableDocs\n        for (var exports_1 = __values(exports), exports_1_1 = exports_1.next(); !exports_1_1.done; exports_1_1 = exports_1.next()) {\n            var exp = exports_1_1.value;\n            switch (exp.flags) {\n                case typescript__WEBPACK_IMPORTED_MODULE_0__[\"SymbolFlags\"].BlockScopedVariable:\n                case typescript__WEBPACK_IMPORTED_MODULE_0__[\"SymbolFlags\"].Variable: {\n                    var node = exp.valueDeclaration;\n                    if (Object(typescript__WEBPACK_IMPORTED_MODULE_0__[\"isVariableDeclaration\"])(node)) {\n                        // Get the nearest variable statement in order to read the jsdoc\n                        var variableStatement = findParent(node, typescript__WEBPACK_IMPORTED_MODULE_0__[\"isVariableStatement\"]) || node;\n                        var jsDoc = getJsDoc(variableStatement, typescript__WEBPACK_IMPORTED_MODULE_0__);\n                        varDocs.push({\n                            kind: \"variable\",\n                            name: node.name.getText(),\n                            description: (_b = jsDoc) === null || _b === void 0 ? void 0 : _b.description,\n                            type: getTypeHintFromType(context.checker.getTypeAtLocation(node), context.checker, context.config)\n                            // TODO: \"summary\"\n                        });\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (exports_1_1 && !exports_1_1.done && (_a = exports_1.return)) _a.call(exports_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return varDocs;\n}\n/**\n * Returns ClassDocs in an analyzer result\n * @param result\n * @param context\n */\nfunction getClassDocsFromAnalyzerResult(result, context) {\n    var e_2, _a;\n    var classDocs = [];\n    try {\n        // Convert all declarations to class docs\n        for (var _b = __values(result.declarations || []), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var decl = _c.value;\n            var doc = getExportsDocFromDeclaration(decl, result, context);\n            if (doc != null) {\n                classDocs.push(doc);\n            }\n        }\n    }\n    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n    finally {\n        try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        }\n        finally { if (e_2) throw e_2.error; }\n    }\n    return classDocs;\n}\n/**\n * Converts a component declaration to ClassDoc, CustomElementDoc or MixinDoc\n * @param declaration\n * @param result\n * @param context\n */\nfunction getExportsDocFromDeclaration(declaration, result, context) {\n    var _a, _b;\n    // Only include \"mixin\" and \"class\" in the output. Interfaces are not outputted..\n    if (declaration.kind === \"interface\") {\n        return undefined;\n    }\n    // Get the superclass of this declaration\n    var superclassHeritage = getSuperclassHeritageClause(declaration);\n    var superclassRef = superclassHeritage == null ? undefined : getReferenceFromHeritageClause(superclassHeritage, context);\n    // Get all mixins\n    var mixinHeritage = getMixinHeritageClauses(declaration);\n    var mixinRefs = arrayDefined(mixinHeritage.map(function (h) { return getReferenceFromHeritageClause(h, context); }));\n    var members = getClassMemberDocsFromDeclaration(declaration, context);\n    var classDoc = {\n        kind: \"class\",\n        superclass: superclassRef,\n        mixins: mixinRefs.length > 0 ? mixinRefs : undefined,\n        description: (_a = declaration.jsDoc) === null || _a === void 0 ? void 0 : _a.description,\n        name: ((_b = declaration.symbol) === null || _b === void 0 ? void 0 : _b.name) || getNodeName(declaration.node, { ts: typescript__WEBPACK_IMPORTED_MODULE_0__ }) || \"\",\n        members: members.length > 0 ? members : undefined\n        // TODO: \"summary\"\n    };\n    // Find the first corresponding custom element definition for this declaration\n    var definition = result.componentDefinitions.find(function (def) { return def.declaration().node === declaration.node; });\n    if (definition != null) {\n        var events = getEventDocsFromDeclaration(declaration, context);\n        var slots = getSlotDocsFromDeclaration(declaration, context);\n        var attributes = getAttributeDocsFromDeclaration(declaration, context);\n        var cssProperties = getCSSPropertyDocsFromDeclaration(declaration, context);\n        var cssParts = getCSSPartDocsFromDeclaration(declaration, context);\n        // Return a custom element doc if a definition was found\n        var customElementDoc = __assign(__assign({}, classDoc), { tagName: definition.tagName, events: events.length > 0 ? events : undefined, slots: slots.length > 0 ? slots : undefined, attributes: attributes.length > 0 ? attributes : undefined, cssProperties: cssProperties.length > 0 ? cssProperties : undefined, cssParts: cssParts.length > 0 ? cssParts : undefined });\n        return customElementDoc;\n    }\n    return classDoc;\n}\n/**\n * Returns event docs for a declaration\n * @param declaration\n * @param context\n */\nfunction getEventDocsFromDeclaration(declaration, context) {\n    return filterVisibility(context.config.visibility, declaration.events).map(function (event) {\n        var _a, _b, _c;\n        return ({\n            description: (_a = event.jsDoc) === null || _a === void 0 ? void 0 : _a.description,\n            name: event.name,\n            detailType: getTypeHintFromType(event.typeHint || ((_c = (_b = event).type) === null || _c === void 0 ? void 0 : _c.call(_b)), context.checker, context.config),\n            type: \"Event\",\n            inheritedFrom: getInheritedFromReference(declaration, event, context)\n            // TODO: missing \"type\"\n        });\n    });\n}\n/**\n * Returns slot docs for a declaration\n * @param declaration\n * @param context\n */\nfunction getSlotDocsFromDeclaration(declaration, context) {\n    return declaration.slots.map(function (slot) {\n        var _a;\n        return ({\n            description: (_a = slot.jsDoc) === null || _a === void 0 ? void 0 : _a.description,\n            name: slot.name || \"\",\n            inheritedFrom: getInheritedFromReference(declaration, slot, context)\n        });\n    });\n}\n/**\n * Returns css properties for a declaration\n * @param declaration\n * @param context\n */\nfunction getCSSPropertyDocsFromDeclaration(declaration, context) {\n    return declaration.cssProperties.map(function (cssProperty) {\n        var _a;\n        return ({\n            name: cssProperty.name,\n            description: (_a = cssProperty.jsDoc) === null || _a === void 0 ? void 0 : _a.description,\n            type: cssProperty.typeHint,\n            default: cssProperty.default != null ? JSON.stringify(cssProperty.default) : undefined,\n            inheritedFrom: getInheritedFromReference(declaration, cssProperty, context)\n        });\n    });\n}\n/**\n * Returns css parts for a declaration\n * @param declaration\n * @param context\n */\nfunction getCSSPartDocsFromDeclaration(declaration, context) {\n    return declaration.cssParts.map(function (cssPart) {\n        var _a;\n        return ({\n            name: cssPart.name,\n            description: (_a = cssPart.jsDoc) === null || _a === void 0 ? void 0 : _a.description,\n            inheritedFrom: getInheritedFromReference(declaration, cssPart, context)\n        });\n    });\n}\n/**\n * Returns attribute docs for a declaration\n * @param declaration\n * @param context\n */\nfunction getAttributeDocsFromDeclaration(declaration, context) {\n    var e_3, _a;\n    var _b, _c, _d;\n    var attributeDocs = [];\n    try {\n        for (var _e = __values(filterVisibility(context.config.visibility, declaration.members)), _f = _e.next(); !_f.done; _f = _e.next()) {\n            var member = _f.value;\n            if (member.attrName != null) {\n                attributeDocs.push({\n                    name: member.attrName,\n                    fieldName: member.propName,\n                    defaultValue: member.default != null ? JSON.stringify(member.default) : undefined,\n                    description: (_b = member.jsDoc) === null || _b === void 0 ? void 0 : _b.description,\n                    type: getTypeHintFromType(member.typeHint || ((_d = (_c = member).type) === null || _d === void 0 ? void 0 : _d.call(_c)), context.checker, context.config),\n                    inheritedFrom: getInheritedFromReference(declaration, member, context)\n                });\n            }\n        }\n    }\n    catch (e_3_1) { e_3 = { error: e_3_1 }; }\n    finally {\n        try {\n            if (_f && !_f.done && (_a = _e.return)) _a.call(_e);\n        }\n        finally { if (e_3) throw e_3.error; }\n    }\n    return attributeDocs;\n}\n/**\n * Returns class member docs for a declaration\n * @param declaration\n * @param context\n */\nfunction getClassMemberDocsFromDeclaration(declaration, context) {\n    return __spread(getFieldDocsFromDeclaration(declaration, context), getMethodDocsFromDeclaration(declaration, context));\n}\n/**\n * Returns method docs for a declaration\n * @param declaration\n * @param context\n */\nfunction getMethodDocsFromDeclaration(declaration, context) {\n    var e_4, _a, e_5, _b;\n    var _c;\n    var methodDocs = [];\n    try {\n        for (var _d = __values(filterVisibility(context.config.visibility, declaration.methods)), _e = _d.next(); !_e.done; _e = _d.next()) {\n            var method = _e.value;\n            var parameters = [];\n            var returnType = undefined;\n            var node = method.node;\n            if (node !== undefined && Object(typescript__WEBPACK_IMPORTED_MODULE_0__[\"isMethodDeclaration\"])(node)) {\n                try {\n                    // Build a list of parameters\n                    for (var _f = (e_5 = void 0, __values(node.parameters)), _g = _f.next(); !_g.done; _g = _f.next()) {\n                        var param = _g.value;\n                        var name_1 = param.name.getText();\n                        var _h = getParameterFromJsDoc(name_1, method.jsDoc), description = _h.description, typeHint = _h.typeHint;\n                        parameters.push({\n                            name: name_1,\n                            type: getTypeHintFromType(typeHint || (param.type != null ? context.checker.getTypeAtLocation(param.type) : undefined), context.checker, context.config),\n                            description: description\n                        });\n                    }\n                }\n                catch (e_5_1) { e_5 = { error: e_5_1 }; }\n                finally {\n                    try {\n                        if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n                    }\n                    finally { if (e_5) throw e_5.error; }\n                }\n                // Get return type\n                var signature = context.checker.getSignatureFromDeclaration(node);\n                if (signature != null) {\n                    returnType = context.checker.getReturnTypeOfSignature(signature);\n                }\n            }\n            // Get return info from jsdoc\n            var _j = getReturnFromJsDoc(method.jsDoc), returnDescription = _j.description, returnTypeHint = _j.typeHint;\n            methodDocs.push({\n                kind: \"method\",\n                name: method.name,\n                privacy: method.visibility,\n                type: getTypeHintFromMethod(method, context.checker),\n                description: (_c = method.jsDoc) === null || _c === void 0 ? void 0 : _c.description,\n                parameters: parameters,\n                return: {\n                    description: returnDescription,\n                    type: getTypeHintFromType(returnTypeHint || returnType, context.checker, context.config)\n                },\n                inheritedFrom: getInheritedFromReference(declaration, method, context)\n                // TODO: \"summary\" and \"static\"\n            });\n        }\n    }\n    catch (e_4_1) { e_4 = { error: e_4_1 }; }\n    finally {\n        try {\n            if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n        }\n        finally { if (e_4) throw e_4.error; }\n    }\n    return methodDocs;\n}\n/**\n * Returns field docs from a declaration\n * @param declaration\n * @param context\n */\nfunction getFieldDocsFromDeclaration(declaration, context) {\n    var e_6, _a;\n    var _b, _c, _d;\n    var fieldDocs = [];\n    try {\n        for (var _e = __values(filterVisibility(context.config.visibility, declaration.members)), _f = _e.next(); !_f.done; _f = _e.next()) {\n            var member = _f.value;\n            if (member.propName != null) {\n                fieldDocs.push({\n                    kind: \"field\",\n                    name: member.propName,\n                    privacy: member.visibility,\n                    description: (_b = member.jsDoc) === null || _b === void 0 ? void 0 : _b.description,\n                    type: getTypeHintFromType(member.typeHint || ((_d = (_c = member).type) === null || _d === void 0 ? void 0 : _d.call(_c)), context.checker, context.config),\n                    default: member.default != null ? JSON.stringify(member.default) : undefined,\n                    inheritedFrom: getInheritedFromReference(declaration, member, context)\n                    // TODO: \"static\" and \"summary\"\n                });\n            }\n        }\n    }\n    catch (e_6_1) { e_6 = { error: e_6_1 }; }\n    finally {\n        try {\n            if (_f && !_f.done && (_a = _e.return)) _a.call(_e);\n        }\n        finally { if (e_6) throw e_6.error; }\n    }\n    return fieldDocs;\n}\nfunction getInheritedFromReference(onDeclaration, feature, context) {\n    if (feature.declaration != null && feature.declaration !== onDeclaration) {\n        return getReferenceForNode(feature.declaration.node, context);\n    }\n    return undefined;\n}\n/**\n * Returns a Reference to a node\n * @param node\n * @param context\n */\nfunction getReferenceForNode(node, context) {\n    var sourceFile = node.getSourceFile();\n    var name = getNodeName(node, context);\n    // Test if the source file is from a typescript lib\n    // TODO: Find a better way of checking this\n    var isLib = sourceFile.isDeclarationFile && sourceFile.fileName.match(/typescript\\/lib.*\\.d\\.ts$/) != null;\n    if (isLib) {\n        // Only return the name of the declaration if it's from lib\n        return {\n            name: name\n        };\n    }\n    // Test if the source file is located in a package\n    var packageName = getPackageName(sourceFile);\n    if (packageName != null) {\n        return {\n            name: name,\n            package: packageName\n        };\n    }\n    // Get the module path name\n    var module = getRelativePath(sourceFile.fileName, context);\n    return {\n        name: name,\n        module: module\n    };\n}\n/**\n * Returns the name of the package (if any)\n * @param sourceFile\n */\nfunction getPackageName(sourceFile) {\n    // TODO: Make it possible to access the ModuleResolutionHost\n    //  in order to resolve the package using \"resolveModuleNames\"\n    //  The following approach is very, very naive and is only temporary.\n    var match = sourceFile.fileName.match(/node_modules\\/(.*?)\\//);\n    if (match != null) {\n        return match[1];\n    }\n    return undefined;\n}\n/**\n * Returns a relative path based on \"cwd\" in the config\n * @param fullPath\n * @param context\n */\nfunction getRelativePath(fullPath, context) {\n    return context.config.cwd != null ? \"./\" + Object(path__WEBPACK_IMPORTED_MODULE_2__[\"relative\"])(context.config.cwd, fullPath) : Object(path__WEBPACK_IMPORTED_MODULE_2__[\"basename\"])(fullPath);\n}\n/**\n * Returns description and typeHint based on jsdoc for a specific parameter name\n * @param name\n * @param jsDoc\n */\nfunction getParameterFromJsDoc(name, jsDoc) {\n    var e_7, _a;\n    var _b;\n    if (((_b = jsDoc) === null || _b === void 0 ? void 0 : _b.tags) == undefined) {\n        return {};\n    }\n    try {\n        for (var _c = __values(jsDoc.tags), _d = _c.next(); !_d.done; _d = _c.next()) {\n            var tag = _d.value;\n            var parsed = tag.parsed();\n            if (parsed.tag === \"param\" && parsed.name === name) {\n                return { description: parsed.description, typeHint: parsed.type };\n            }\n        }\n    }\n    catch (e_7_1) { e_7 = { error: e_7_1 }; }\n    finally {\n        try {\n            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        }\n        finally { if (e_7) throw e_7.error; }\n    }\n    return {};\n}\n/**\n * Get return description and return typeHint from jsdoc\n * @param jsDoc\n */\nfunction getReturnFromJsDoc(jsDoc) {\n    var _a, _b;\n    var tag = (_b = (_a = jsDoc) === null || _a === void 0 ? void 0 : _a.tags) === null || _b === void 0 ? void 0 : _b.find(function (tag) { return [\"returns\", \"return\"].includes(tag.tag); });\n    if (tag == null) {\n        return {};\n    }\n    var parsed = tag.parsed();\n    return { description: parsed.description, typeHint: parsed.type };\n}\n/**\n * Converts a heritage clause into a reference\n * @param heritage\n * @param context\n */\nfunction getReferenceFromHeritageClause(heritage, context) {\n    var _a;\n    var node = (_a = heritage.declaration) === null || _a === void 0 ? void 0 : _a.node;\n    var identifier = heritage.identifier;\n    // Return a reference for this node if any\n    if (node != null) {\n        return getReferenceForNode(node, context);\n    }\n    // Try to get declaration of the identifier if no node was found\n    var _b = __read(resolveDeclarations(identifier, context), 1), declaration = _b[0];\n    if (declaration != null) {\n        return getReferenceForNode(declaration, context);\n    }\n    // Just return the name of the reference if nothing could be resolved\n    var name = getNodeName(identifier, context);\n    if (name != null) {\n        return { name: name };\n    }\n    return undefined;\n}\n/**\n * Flatten all analyzer results with inherited declarations\n * @param results\n */\nfunction flattenAnalyzerResults(results) {\n    var e_8, _a, e_9, _b;\n    // Keep track of declarations in each source file\n    var declarationMap = new Map();\n    /**\n     * Add a declaration to the declaration map\n     * @param declaration\n     */\n    function addDeclarationToMap(declaration) {\n        var sourceFile = declaration.node.getSourceFile();\n        var exportDocs = declarationMap.get(sourceFile) || new Set();\n        if (!declarationMap.has(sourceFile)) {\n            declarationMap.set(sourceFile, exportDocs);\n        }\n        exportDocs.add(declaration);\n    }\n    try {\n        for (var results_1 = __values(results), results_1_1 = results_1.next(); !results_1_1.done; results_1_1 = results_1.next()) {\n            var result = results_1_1.value;\n            try {\n                for (var _c = (e_9 = void 0, __values(result.declarations || [])), _d = _c.next(); !_d.done; _d = _c.next()) {\n                    var decl = _d.value;\n                    // Add all existing declarations to the map\n                    addDeclarationToMap(decl);\n                    visitAllHeritageClauses(decl, function (clause) {\n                        // Flatten all component declarations\n                        if (clause.declaration != null) {\n                            addDeclarationToMap(clause.declaration);\n                        }\n                    });\n                }\n            }\n            catch (e_9_1) { e_9 = { error: e_9_1 }; }\n            finally {\n                try {\n                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\n                }\n                finally { if (e_9) throw e_9.error; }\n            }\n        }\n    }\n    catch (e_8_1) { e_8 = { error: e_8_1 }; }\n    finally {\n        try {\n            if (results_1_1 && !results_1_1.done && (_a = results_1.return)) _a.call(results_1);\n        }\n        finally { if (e_8) throw e_8.error; }\n    }\n    // Return new results with flattened declarations\n    return results.map(function (result) {\n        var declarations = declarationMap.get(result.sourceFile);\n        return __assign(__assign({}, result), { declarations: declarations != null ? Array.from(declarations) : result.declarations });\n    });\n}\n\n/**\n * Parses and returns examples for a component.\n * @param declaration\n */\nfunction getExamplesFromComponent(declaration) {\n    var _a, _b;\n    var examples = ((_b = (_a = declaration.jsDoc) === null || _a === void 0 ? void 0 : _a.tags) === null || _b === void 0 ? void 0 : _b.filter(function (tag) { return tag.tag === \"example\" || tag.tag === \"demo\"; })) || [];\n    return examples.map(exampleFromJsDocTag);\n}\n/**\n * Returns an example based on a jsdoc tag\n * @param tag\n */\nfunction exampleFromJsDocTag(tag) {\n    var _a = discoverCodeFromExampleText(tag.comment || \"\"), code = _a.code, lang = _a.lang, description = _a.description;\n    return {\n        lang: lang,\n        description: description,\n        code: code\n    };\n}\n/**\n * Parses some text and returns the first found example\n * @param text\n */\nfunction discoverCodeFromExampleText(text) {\n    // Check if there is a code example already like this: ```code here ```\n    var escapedCodeMatch = text.match(/([\\s\\S]*)```(\\S*)([\\s\\S]+)```/);\n    if (escapedCodeMatch != null) {\n        return {\n            description: (escapedCodeMatch[1] || \"\").trim() || undefined,\n            lang: escapedCodeMatch[2] || undefined,\n            code: (escapedCodeMatch[3] || \"\").trim()\n        };\n    }\n    // Else, assume that the text is the code\n    return { code: text.trim(), lang: discoverLanguageFromExampleText(text) };\n}\n/**\n * Returns the language of some code based on assumptions\n * @param code\n */\nfunction discoverLanguageFromExampleText(code) {\n    if (code.includes(\"html`\")) {\n        return \"javascript\";\n    }\n    if (code.match(/<\\S/)) {\n        return \"html\";\n    }\n    return \"javascript\";\n}\n\n/**\n * Returns a markdown header with a specific level taking global start title level into account.\n * @param title\n * @param level\n * @param config\n */\nfunction markdownHeader(title, level, config) {\n    var _a, _b;\n    level = level - 1 + (((_a = config.markdown) === null || _a === void 0 ? void 0 : _a.headerLevel) || ((_b = config.markdown) === null || _b === void 0 ? void 0 : _b.titleLevel) || 1);\n    return \"#\".repeat(level) + \" \" + title;\n}\n/**\n * Returns a markdown table representation of the rows.\n * Strips unused columns.\n * @param rows\n * @param removeEmptyColumns\n */\nfunction markdownTable(rows, _a) {\n    var removeEmptyColumns = (_a === void 0 ? { removeEmptyColumns: true } : _a).removeEmptyColumns;\n    // Constants for pretty printing the markdown tables\n    var MIN_CELL_WIDTH = 3;\n    var MAX_CELL_WIDTH = 50;\n    var CELL_PADDING = 1;\n    // Count the number of columns\n    var columnCount = Math.max.apply(Math, __spread(rows.map(function (r) { return r.length; })));\n    if (removeEmptyColumns) {\n        // Create a boolean array where each entry tells if a column is used or not (excluding the header)\n        var emptyColumns_1 = Array(columnCount)\n            .fill(false)\n            .map(function (b, i) { return i !== 0 && rows.slice(1).find(function (r) { return r[i] != null && r[i].length > 0; }) == null; });\n        // Remove unused columns if necessary\n        if (emptyColumns_1.includes(true)) {\n            // Filter out the unused columns in each row\n            rows = rows.map(function (row) { return row.filter(function (column, i) { return !emptyColumns_1[i]; }); });\n            // Adjust the column count\n            columnCount = Math.max.apply(Math, __spread(rows.map(function (r) { return r.length; })));\n        }\n    }\n    // Escape all cells in the markdown output\n    rows = rows.map(function (r) { return r.map(markdownEscapeTableCell); });\n    // Create a boolean array where each entry corresponds to the preferred column width.\n    // This is done by taking the largest width of all cells in each column.\n    var columnWidths = Array(columnCount)\n        .fill(0)\n        .map(function (c, i) { return Math.min(MAX_CELL_WIDTH, Math.max.apply(Math, __spread([MIN_CELL_WIDTH], rows.map(function (r) { return (r[i] || \"\").length; }))) + CELL_PADDING * 2); });\n    // Build up the table\n    return \"\\n|\" + rows[0].map(function (r, i) { return fillWidth(r, columnWidths[i], CELL_PADDING); }).join(\"|\") + \"|\\n|\" + columnWidths.map(function (c) { return \"-\".repeat(c); }).join(\"|\") + \"|\\n\" + rows\n        .slice(1)\n        .map(function (r) { return \"|\" + r.map(function (r, i) { return fillWidth(r, columnWidths[i], CELL_PADDING); }).join(\"|\") + \"|\"; })\n        .join(\"\\n\") + \"\\n\";\n}\n/**\n * Escape a text so it can be used in a markdown table\n * @param text\n */\nfunction markdownEscapeTableCell(text) {\n    return text.replace(/\\n/g, \"<br />\").replace(/\\|/g, \"\\\\|\");\n}\n/**\n * Highlights some text\n * @param text\n */\nfunction markdownHighlight(text) {\n    if (text == null || text.length === 0)\n        return \"\";\n    return \"`\" + text + \"`\";\n}\n/**\n * Creates padding around some text with a target width.\n * @param text\n * @param width\n * @param paddingStart\n */\nfunction fillWidth(text, width, paddingStart) {\n    return \" \".repeat(paddingStart) + text + \" \".repeat(Math.max(1, width - text.length - paddingStart));\n}\n\n/**\n * Transforms the component results to markdown\n * @param results\n * @param program\n * @param config\n */\nvar markdownTransformer = function (results, program, config) {\n    // Grab all definitions\n    var definitions = arrayFlat(results.map(function (res) { return res.componentDefinitions; }));\n    // Transform all definitions to markdown\n    var markdownSegments = definitions.map(function (definition) {\n        var e_1, _a;\n        var _b, _c;\n        var declaration = definition.declaration();\n        // Add tagName as header\n        var segmentText = markdownHeader(definition.tagName, 1, config) + \"\\n\";\n        // Add component jsdoc comment to the output\n        if (((_b = declaration.jsDoc) === null || _b === void 0 ? void 0 : _b.description) != null)\n            segmentText += \"\\n\" + ((_c = declaration.jsDoc) === null || _c === void 0 ? void 0 : _c.description) + \"\\n\";\n        // Add mixins (don't include mixins prefixed with _)\n        var mixins = arrayDefined(getMixinHeritageClausesInChain(declaration).map(function (clause) { var _a, _b; return ((_b = (_a = clause.declaration) === null || _a === void 0 ? void 0 : _a.symbol) === null || _b === void 0 ? void 0 : _b.name) || clause.identifier.getText(); })).filter(function (name) { return !name.startsWith(\"_\"); });\n        if (mixins.length > 0) {\n            segmentText += \"\\n**Mixins:** \" + mixins.join(\", \") + \"\\n\";\n        }\n        // Add examples\n        var examples = getExamplesFromComponent(declaration);\n        if (examples.length > 0) {\n            segmentText += \"\\n\" + markdownHeader(\"Example\" + (examples.length > 1 ? \"s\" : \"\"), 2, config) + \"\\n\";\n            try {\n                for (var examples_1 = __values(examples), examples_1_1 = examples_1.next(); !examples_1_1.done; examples_1_1 = examples_1.next()) {\n                    var example = examples_1_1.value;\n                    if (example.description != null) {\n                        segmentText += \"\\n\" + example.description + \"\\n\";\n                    }\n                    segmentText += \"\\n```\" + (example.lang || \"\") + \"\\n\" + example.code + \"\\n```\\n\";\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (examples_1_1 && !examples_1_1.done && (_a = examples_1.return)) _a.call(examples_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        }\n        // Grab all items from the component and add them as tables to the output.\n        var properties = filterVisibility(config.visibility, declaration.members.filter(function (m) { return m.kind === \"property\"; }).sort(function (a, b) { return (a.propName < b.propName ? -1 : 1); }));\n        var attributes = filterVisibility(config.visibility, declaration.members.filter(function (m) { return m.kind === \"attribute\"; }).sort(function (a, b) { return (a.attrName < b.attrName ? -1 : 1); }));\n        var methods = filterVisibility(config.visibility, declaration.methods.sort(function (a, b) { return (a.name < b.name ? -1 : 1); }));\n        var slots = declaration.slots.sort(function (a, b) { return (a.name == null ? -1 : b.name == null ? 1 : a.name < b.name ? -1 : 1); });\n        var events = declaration.events.sort(function (a, b) { return (a.name < b.name ? -1 : 1); });\n        var cssProps = declaration.cssProperties.sort(function (a, b) { return (a.name < b.name ? -1 : 1); });\n        var cssParts = declaration.cssParts.sort(function (a, b) { return (a.name < b.name ? -1 : 1); });\n        if (attributes.length > 0) {\n            segmentText += \"\\n\" + memberAttributeSection(attributes, program.getTypeChecker(), config);\n        }\n        if (properties.length > 0) {\n            segmentText += \"\\n\" + memberPropertySection(properties, program.getTypeChecker(), config);\n        }\n        if (methods.length > 0) {\n            segmentText += \"\\n\" + methodSection(methods, program.getTypeChecker(), config);\n        }\n        if (events.length > 0) {\n            segmentText += \"\\n\" + eventSection(events, program.getTypeChecker(), config);\n        }\n        if (slots.length > 0) {\n            segmentText += \"\\n\" + slotSection(slots, config);\n        }\n        if (cssParts.length > 0) {\n            segmentText += \"\\n\" + cssPartSection(cssParts, config);\n        }\n        if (cssProps.length > 0) {\n            segmentText += \"\\n\" + cssPropSection(cssProps, config);\n        }\n        return segmentText;\n    });\n    return markdownSegments.join(\"\\n\\n\");\n};\n/**\n * Returns a markdown table with css props\n * @param cssProperties\n * @param config\n */\nfunction cssPropSection(cssProperties, config) {\n    var rows = [[\"Property\", \"Type\", \"Default\", \"Description\"]];\n    rows.push.apply(rows, __spread(cssProperties.map(function (prop) {\n        var _a;\n        var def = (prop.default !== undefined ? JSON.stringify(prop.default) : \"\") || \"\";\n        return [(prop.name && markdownHighlight(prop.name)) || \"\", prop.typeHint || \"\", def, ((_a = prop.jsDoc) === null || _a === void 0 ? void 0 : _a.description) || \"\"];\n    })));\n    return markdownHeader(\"CSS Custom Properties\", 2, config) + \"\\n\" + markdownTable(rows);\n}\n/**\n * Returns a markdown table with css parts\n * @param cssPart\n * @param config\n */\nfunction cssPartSection(cssPart, config) {\n    var rows = [[\"Part\", \"Description\"]];\n    rows.push.apply(rows, __spread(cssPart.map(function (part) { var _a; return [(part.name && markdownHighlight(part.name)) || \"\", ((_a = part.jsDoc) === null || _a === void 0 ? void 0 : _a.description) || \"\"]; })));\n    return markdownHeader(\"CSS Shadow Parts\", 2, config) + \"\\n\" + markdownTable(rows);\n}\n/**\n * Returns a markdown table with methods\n * @param methods\n * @param checker\n * @param config\n */\nfunction methodSection(methods, checker, config) {\n    var showVisibility = shouldShowVisibility(methods, config);\n    var rows = [[\"Method\", \"Visibility\", \"Type\", \"Description\"]];\n    rows.push.apply(rows, __spread(methods.map(function (method) {\n        var _a, _b, _c;\n        // Build up a description of parameters\n        var paramDescription = ((_b = (_a = method.jsDoc) === null || _a === void 0 ? void 0 : _a.tags) === null || _b === void 0 ? void 0 : _b.filter(function (tag) { return tag.tag === \"param\" && tag.comment != null; }).map(function (tag) {\n            return \"**\" + tag.parsed().name + \"**: \" + tag.parsed().description;\n        }).join(\"\\n\").trim()) || undefined;\n        var description = ((_c = method.jsDoc) === null || _c === void 0 ? void 0 : _c.description) || undefined;\n        return [\n            method.name != null ? markdownHighlight(method.name) : \"\",\n            showVisibility ? method.visibility || \"public\" : \"\",\n            markdownHighlight(getTypeHintFromMethod(method, checker)),\n            \"\" + (description || \"\") + (description != null && paramDescription != null ? \"\\n\\n\" : \"\") + (paramDescription || \"\")\n        ];\n    })));\n    return markdownHeader(\"Methods\", 2, config) + \"\\n\" + markdownTable(rows);\n}\n/**\n * Returns a markdown table with events\n * @param events\n * @param config\n * @param checker\n */\nfunction eventSection(events, checker, config) {\n    var showVisibility = shouldShowVisibility(events, config);\n    var rows = [[\"Event\", \"Visibility\", \"Detail\", \"Description\"]];\n    rows.push.apply(rows, __spread(events.map(function (event) {\n        var _a, _b, _c, _d;\n        return [\n            (event.name && markdownHighlight(event.name)) || \"\",\n            showVisibility ? event.visibility || \"public\" : \"\",\n            markdownHighlight(getTypeHintFromType((_a = event.typeHint, (_a !== null && _a !== void 0 ? _a : (_c = (_b = event).type) === null || _c === void 0 ? void 0 : _c.call(_b))), checker, config)),\n            ((_d = event.jsDoc) === null || _d === void 0 ? void 0 : _d.description) || \"\"\n        ];\n    })));\n    return markdownHeader(\"Events\", 2, config) + \"\\n\" + markdownTable(rows);\n}\n/**\n * Returns a markdown table with slots\n * @param slots\n * @param config\n */\nfunction slotSection(slots, config) {\n    var rows = [[\"Name\", \"Permitted Tag Names\", \"Description\"]];\n    rows.push.apply(rows, __spread(slots.map(function (slot) {\n        var _a;\n        return [\n            (slot.name && markdownHighlight(slot.name)) || \"\",\n            (slot.permittedTagNames && slot.permittedTagNames.map(function (tagName) { return markdownHighlight(tagName); }).join(\" | \")) || \"\",\n            ((_a = slot.jsDoc) === null || _a === void 0 ? void 0 : _a.description) || \"\"\n        ];\n    })));\n    return markdownHeader(\"Slots\", 2, config) + \"\\n\" + markdownTable(rows);\n}\n/**\n * Returns a markdown table with attributes.\n * @param members\n * @param checker\n * @param config\n */\nfunction memberAttributeSection(members, checker, config) {\n    var e_2, _a;\n    var _b, _c, _d, _e;\n    var showVisibility = shouldShowVisibility(members, config);\n    var rows = [[\"Attribute\", \"Visibility\", \"Type\", \"Default\", \"Description\"]];\n    try {\n        // Add members as rows one by one\n        for (var members_1 = __values(members), members_1_1 = members_1.next(); !members_1_1.done; members_1_1 = members_1.next()) {\n            var member = members_1_1.value;\n            var attrName = markdownHighlight(member.attrName);\n            var type = markdownHighlight(getTypeHintFromType((_b = member.typeHint, (_b !== null && _b !== void 0 ? _b : (_d = (_c = member).type) === null || _d === void 0 ? void 0 : _d.call(_c))), checker, config));\n            var visibility = member.visibility || \"public\";\n            var def = (member.default !== undefined ? JSON.stringify(member.default) : \"\") || (member.required && \"**required**\") || \"\";\n            var comment = ((_e = member.jsDoc) === null || _e === void 0 ? void 0 : _e.description) || \"\";\n            rows.push([attrName, showVisibility ? visibility : \"\", type, def, comment]);\n        }\n    }\n    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n    finally {\n        try {\n            if (members_1_1 && !members_1_1.done && (_a = members_1.return)) _a.call(members_1);\n        }\n        finally { if (e_2) throw e_2.error; }\n    }\n    return markdownHeader(\"Attributes\", 2, config) + \"\\n\" + markdownTable(rows);\n}\n/**\n * Returns a markdown table with properties\n * @param members\n * @param checker\n * @param config\n */\nfunction memberPropertySection(members, checker, config) {\n    var e_3, _a;\n    var _b, _c, _d, _e;\n    var showVisibility = shouldShowVisibility(members, config);\n    var rows = [[\"Property\", \"Attribute\", \"Visibility\", \"Modifiers\", \"Type\", \"Default\", \"Description\"]];\n    try {\n        // Add properties as rows one by one\n        for (var members_2 = __values(members), members_2_1 = members_2.next(); !members_2_1.done; members_2_1 = members_2.next()) {\n            var member = members_2_1.value;\n            var propName = markdownHighlight(member.propName);\n            var attrName = (member.attrName && markdownHighlight(member.attrName)) || \"\";\n            var visibility = member.visibility || \"public\";\n            var type = markdownHighlight(getTypeHintFromType((_b = member.typeHint, (_b !== null && _b !== void 0 ? _b : (_d = (_c = member).type) === null || _d === void 0 ? void 0 : _d.call(_c))), checker, config));\n            var mods = member.modifiers != null ? Array.from(member.modifiers).join(\", \") : \"\";\n            var def = (member.default !== undefined ? JSON.stringify(member.default) : \"\") || (member.required && \"**required**\") || \"\";\n            var comment = ((_e = member.jsDoc) === null || _e === void 0 ? void 0 : _e.description) || \"\";\n            rows.push([propName, attrName, showVisibility ? visibility : \"\", mods, type, def, comment]);\n        }\n    }\n    catch (e_3_1) { e_3 = { error: e_3_1 }; }\n    finally {\n        try {\n            if (members_2_1 && !members_2_1.done && (_a = members_2.return)) _a.call(members_2);\n        }\n        finally { if (e_3) throw e_3.error; }\n    }\n    return markdownHeader(\"Properties\", 2, config) + \"\\n\" + markdownTable(rows);\n}\nfunction shouldShowVisibility(items, config) {\n    return (config.visibility != null && config.visibility !== \"public\" && items.some(function (method) { return method.visibility != null && method.visibility !== \"public\"; }));\n}\n\n/**\n * Vscode json output format transformer.\n * @param results\n * @param program\n * @param config\n */\nvar vscodeTransformer = function (results, program, config) {\n    var checker = program.getTypeChecker();\n    // Grab all definitions\n    var definitions = results.map(function (res) { return res.componentDefinitions; }).reduce(function (acc, cur) { return __spread(acc, cur); }, []);\n    // Transform all definitions into \"tags\"\n    var tags = definitions.map(function (d) { return definitionToHtmlDataTag$1(d, checker); });\n    var vscodeJson = {\n        version: 1,\n        tags: tags,\n        globalAttributes: [],\n        valueSets: []\n    };\n    return JSON.stringify(vscodeJson, null, 2);\n};\nfunction definitionToHtmlDataTag$1(definition, checker) {\n    var declaration = definition.declaration();\n    // Transform all members into \"attributes\"\n    var customElementAttributes = arrayDefined(declaration.members.map(function (d) { return componentMemberToVscodeAttr(d, checker); }));\n    var eventAttributes = arrayDefined(declaration.events.map(function (e) { return componentEventToVscodeAttr(e, checker); }));\n    var attributes = __spread(customElementAttributes, eventAttributes);\n    return {\n        name: definition.tagName,\n        description: formatMetadata(declaration.jsDoc, {\n            Events: declaration.events.map(function (e) { var _a, _b; return formatEntryRow(e.name, e.jsDoc, (_b = (_a = e).type) === null || _b === void 0 ? void 0 : _b.call(_a), checker); }),\n            Slots: declaration.slots.map(function (s) {\n                return formatEntryRow(s.name || \" \", s.jsDoc, s.permittedTagNames && s.permittedTagNames.map(function (n) { return \"\\\"\" + markdownHighlight(n) + \"\\\"\"; }).join(\" | \"), checker);\n            }),\n            Attributes: declaration.members\n                .map(function (m) { var _a, _b; return (\"attrName\" in m && m.attrName != null ? formatEntryRow(m.attrName, m.jsDoc, m.typeHint || ((_b = (_a = m).type) === null || _b === void 0 ? void 0 : _b.call(_a)), checker) : undefined); })\n                .filter(function (m) { return m != null; }),\n            Properties: declaration.members\n                .map(function (m) { var _a, _b; return (\"propName\" in m && m.propName != null ? formatEntryRow(m.propName, m.jsDoc, m.typeHint || ((_b = (_a = m).type) === null || _b === void 0 ? void 0 : _b.call(_a)), checker) : undefined); })\n                .filter(function (m) { return m != null; })\n        }),\n        attributes: attributes\n    };\n}\nfunction componentEventToVscodeAttr(event, checker) {\n    var _a, _b;\n    return {\n        name: \"on\" + event.name,\n        description: formatEntryRow(event.name, event.jsDoc, (_b = (_a = event).type) === null || _b === void 0 ? void 0 : _b.call(_a), checker)\n    };\n}\nfunction componentMemberToVscodeAttr(member, checker) {\n    var _a, _b, _c, _d;\n    if (member.attrName == null) {\n        return undefined;\n    }\n    return __assign({ name: member.attrName, description: formatMetadata(formatEntryRow(member.attrName, member.jsDoc, member.typeHint || ((_b = (_a = member).type) === null || _b === void 0 ? void 0 : _b.call(_a)), checker), {\n            Property: \"propName\" in member ? member.propName : undefined,\n            Default: member.default === undefined ? undefined : String(member.default)\n        }) }, ((member.type && typeToVscodeValuePart((_d = (_c = member).type) === null || _d === void 0 ? void 0 : _d.call(_c), checker)) || {}));\n}\n/**\n * Converts a type to either a value set or string unions.\n * @param type\n * @param checker\n */\nfunction typeToVscodeValuePart(type, checker) {\n    var simpleType = Object(ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"isSimpleType\"])(type) ? type : Object(ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"toSimpleType\"])(type, checker);\n    switch (simpleType.kind) {\n        case ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].BOOLEAN:\n            return { valueSet: \"v\" };\n        case ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].STRING_LITERAL:\n            return { values: [{ name: simpleType.value }] };\n        case ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].ENUM:\n            return { values: typesToStringUnion(simpleType.types.map(function (_a) {\n                    var type = _a.type;\n                    return type;\n                })) };\n        case ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].UNION:\n            return { values: typesToStringUnion(simpleType.types) };\n    }\n    return undefined;\n}\n/**\n * Returns a list of strings that represents the types.\n * Only looks at literal types and strips the rest.\n * @param types\n */\nfunction typesToStringUnion(types) {\n    return arrayDefined(types.map(function (t) {\n        switch (t.kind) {\n            case ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].STRING_LITERAL:\n            case ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].NUMBER_LITERAL:\n                return { name: t.value.toString() };\n            default:\n                return undefined;\n        }\n    }));\n}\n/**\n * Formats description and metadata so that it can be used in documentation.\n * @param doc\n * @param metadata\n */\nfunction formatMetadata(doc, metadata) {\n    var _a;\n    var metaText = arrayDefined(Object.entries(metadata).map(function (_a) {\n        var _b = __read(_a, 2), key = _b[0], value = _b[1];\n        if (value == null) {\n            return undefined;\n        }\n        else if (Array.isArray(value)) {\n            var filtered = arrayDefined(value);\n            if (filtered.length === 0)\n                return undefined;\n            return key + \":\\n\\n\" + filtered.map(function (v) { return \"  * \" + v; }).join(\"\\n\\n\");\n        }\n        else {\n            return key + \": \" + value;\n        }\n    })).join(\"\\n\\n\");\n    var comment = typeof doc === \"string\" ? doc : ((_a = doc) === null || _a === void 0 ? void 0 : _a.description) || \"\";\n    return \"\" + (comment || \"\") + (metadata ? \"\" + (comment ? \"\\n\\n\" : \"\") + metaText : \"\") || undefined;\n}\n/**\n * Formats name, doc and type so that it can be presented in documentation\n * @param name\n * @param doc\n * @param type\n * @param checker\n */\nfunction formatEntryRow(name, doc, type, checker) {\n    var _a;\n    var comment = typeof doc === \"string\" ? doc : ((_a = doc) === null || _a === void 0 ? void 0 : _a.description) || \"\";\n    var typeText = typeof type === \"string\" ? type : type == null ? \"\" : formatType(type, checker);\n    return \"\" + markdownHighlight(name) + (typeText == null ? \"\" : \" {\" + typeText + \"}\") + (comment == null ? \"\" : \" - \") + (comment || \"\");\n}\n/**\n * Formats a type to present in documentation\n * @param type\n * @param checker\n */\nfunction formatType(type, checker) {\n    return !Object(ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"isAssignableToSimpleTypeKind\"])(type, ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"SimpleTypeKind\"].ANY, checker) ? markdownHighlight(Object(ts_simple_type__WEBPACK_IMPORTED_MODULE_1__[\"toTypeString\"])(type, checker)) : undefined;\n}\n\nvar transformerFunctionMap = {\n    debug: debugJsonTransformer,\n    json: jsonTransformer,\n    json2: json2Transformer,\n    markdown: markdownTransformer,\n    md: markdownTransformer,\n    vscode: vscodeTransformer\n};\n/**\n * Transforms the analyzer results into a string representation based on the transformer kind\n * @param kind\n * @param results\n * @param program\n * @param config\n */\nfunction transformAnalyzerResult(kind, results, program, config) {\n    if (config === void 0) { config = {}; }\n    var func = transformerFunctionMap[kind];\n    if (func == null) {\n        throw new Error(\"Couldn't find transformer function for transformer kind: \" + kind);\n    }\n    return func(Array.isArray(results) ? results : [results], program, __assign({ visibility: \"public\" }, config));\n}\n\n\n\n\n//# sourceURL=webpack:////Users/rune/Developer/js/web-component-analyzer/lib/esm/chunk-2799b223.js?");

/***/ }),

/***/ "../../web-component-analyzer/node_modules/typescript/lib sync recursive":
/*!****************************************************************************************!*\
  !*** /Users/rune/Developer/js/web-component-analyzer/node_modules/typescript/lib sync ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = \"../../web-component-analyzer/node_modules/typescript/lib sync recursive\";\n\n//# sourceURL=webpack:////Users/rune/Developer/js/web-component-analyzer/node_modules/typescript/lib_sync?");

/***/ }),

/***/ 0:
/*!*******************************************!*\
  !*** @microsoft/typescript-etw (ignored) ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack:///@microsoft/typescript-etw_(ignored)?");

/***/ }),

/***/ 1:
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack:///fs_(ignored)?");

/***/ }),

/***/ 2:
/*!**********************!*\
  !*** path (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack:///path_(ignored)?");

/***/ }),

/***/ 3:
/*!********************!*\
  !*** os (ignored) ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack:///os_(ignored)?");

/***/ }),

/***/ 4:
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack:///crypto_(ignored)?");

/***/ }),

/***/ 5:
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack:///buffer_(ignored)?");

/***/ }),

/***/ 6:
/*!************************************!*\
  !*** source-map-support (ignored) ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack:///source-map-support_(ignored)?");

/***/ }),

/***/ 7:
/*!***************************!*\
  !*** inspector (ignored) ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack:///inspector_(ignored)?");

/***/ })

}]);